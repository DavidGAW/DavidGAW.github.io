<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ellen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gengaiwei.com/"/>
  <updated>2020-07-24T05:52:48.071Z</updated>
  <id>http://gengaiwei.com/</id>
  
  <author>
    <name>Ellen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript（二）：接口与类</title>
    <link href="http://gengaiwei.com/2020/07/24/TypeScript%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB/"/>
    <id>http://gengaiwei.com/2020/07/24/TypeScript（二）：接口与类/</id>
    <published>2020-07-24T04:31:06.000Z</published>
    <updated>2020-07-24T05:52:48.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TypeScript  的核心之一 就是对值（数据）所具有的结构进行类型检查、类型的约定、除了基本类型的检查，还有就是接口，用接口来进行标注；</p><h3 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h3><pre><code>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现；是对复杂的对象类型进行标注的一种方式，或者给其他代码定义一种契约（比如：类）。</code></pre><h4 id="1-对【对象的形状】进行描述"><a href="#1-对【对象的形状】进行描述" class="headerlink" title="1. 对【对象的形状】进行描述"></a>1. 对【对象的形状】进行描述</h4><p>基本使用：举个🌰<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注：接口一般首字母大写</p><p>标注此接口 接口仅表示一种类型 不能作为值去使用，并且用接口的变量 需要履行契约；定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//接口中有 name、age</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这么写 会报错 缺少 age</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//这么写 会报错 gender不在类型Person中</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender:  &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><table><tr><td bgcolor="orange">所以：赋值的时候，变量的形状必须和接口的形状保持一致 </td></tr></table><blockquote><p>接口的其他属性规则:</p></blockquote><h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><p>接口中的某个属性 可以不存在，但也不能添加未定义的属性</p><p>在属性 <code>：</code>  前加 <code>？</code> ，这样此接口属性被履行时，<code>gender</code> 被视为可选属性<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:number;</span><br><span class="line">    gender?:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let who :Person =&#123;</span><br><span class="line">    name:&apos;zhangsan&apos;,</span><br><span class="line">    age:18,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h5><p>如果我们希望对象中的一些字段只能在创建的时候被复制，那么就可以用<code>readonly</code> 定义只读属性， 只能用来读取 ,不可被修改<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person1&#123;</span><br><span class="line">    readonly name:string;</span><br><span class="line">    readonly age:number;</span><br><span class="line">    tel?:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建时 赋值</span><br><span class="line">let per1 : Person1 = &#123;</span><br><span class="line">    name:&apos;lisi&apos;,</span><br><span class="line">    age:18,</span><br><span class="line">    tel:&apos;155....&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">per1.age;</span><br><span class="line">per1.age = 20;    //报错：无法分配到&quot;age&quot; ，因为它是只读属性</span><br><span class="line">per1.tel= &apos;133…’  //可以被修改</span><br></pre></td></tr></table></figure></p><h5 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h5><p>当接口中已标注属性不满足我们需要的属性时，当我们不知道除了<code>name</code>、<code>age</code>属性外还有其他什么属性的时候，并且需要扩展接口属性的时候；【占位符】<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person2&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:string;</span><br><span class="line">    [propName:string]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let per2 : Person2 = &#123;</span><br><span class="line">    name:&apos;lisi&apos;,</span><br><span class="line">    age:&apos;18&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">per2[&apos;gender&apos;] = &apos;male&apos;; //或者 per2.gender= “male&quot; ;</span><br></pre></td></tr></table></figure></p><p>注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number; // 报错：’age&apos;的 &apos;number&apos;不是’string&apos;的子属性.</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25, </span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一个接口只能定义一个任意属性，如果接口中有多个类型的属性，则可以在任意属性中使用联合类型<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number; //这样就不报错了</span><br><span class="line">    [propName: string]: string | number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25, </span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="2-对【类】的一部分行为进行抽象，用【类】实现接口"><a href="#2-对【类】的一部分行为进行抽象，用【类】实现接口" class="headerlink" title="2.  对【类】的一部分行为进行抽象，用【类】实现接口"></a>2.  对【类】的一部分行为进行抽象，用【类】实现接口</h4><p>在类中使用必须要被遵循的接口可以使用 <code>implements</code> 关键字来确保其兼容性：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Someone&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Students implements Someone &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name:string,age:number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        console.log(`$&#123;this.age&#125; 岁的 $&#123;this.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newP = new Students(“Luke&quot;, 18);</span><br></pre></td></tr></table></figure></p><p>进阶一下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Teacher extends Students implements Someone &#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    constructor(name:string,age:number)&#123;    </span><br><span class="line">        super(name,age); //表示当前继承的类Students的构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        console.log(`$&#123;this.name&#125;那年:$&#123;this.age&#125;岁`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newT = new Teacher(&apos;youda&apos;,1000)</span><br></pre></td></tr></table></figure></p><h4 id="3-接口的继承"><a href="#3-接口的继承" class="headerlink" title="3.  接口的继承"></a>3.  接口的继承</h4><p>使用 关键字 <code>extends</code> 来继承<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Someone&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Skill extends Someone&#123;</span><br><span class="line">    category1:string;</span><br><span class="line">    category2:string;</span><br><span class="line">    category3:string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以当定义变量 使用 <code>Skill</code> 时，需要遵循接口的属性，如下<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let onePer : Skill = &#123;</span><br><span class="line">    name:&apos;luke&apos;,</span><br><span class="line">    age:40,</span><br><span class="line">    category1:&apos;html&apos;,</span><br><span class="line">    category2:&apos;js&apos;,</span><br><span class="line">    category3:&apos;css&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另：接口还可以继承多个接口  使用  <code>逗号</code> 隔开；<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Who extends Skill,Someone&#123;</span><br><span class="line">    teacher:string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h3><p>我们知道类定义了一件事物的抽象特点，包含它的属性和方法，还有类的实例是通过 <code>new</code> 生成，TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><h4 id="1-ES6中类的用法"><a href="#1-ES6中类的用法" class="headerlink" title="1. ES6中类的用法"></a>1. ES6中类的用法</h4><blockquote><p>(1). 属性和方法</p></blockquote><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `我是 $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oneSt = new Student(&quot;luke_st&quot;);</span><br><span class="line">console.log(oneSt.sayHi());</span><br></pre></td></tr></table></figure></p><blockquote><p>(2). 类的继承</p></blockquote><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Dad &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        console.log(`im your dad`)</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `我是你$&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Dad &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name); // 调用父类的 constructor(name)</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `你好 $&#123;super.sayHi()&#125;`; // 调用父类的 sayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s = new Son(&apos;erzi&apos;);</span><br><span class="line">console.log(s.sayHi());</span><br></pre></td></tr></table></figure></p><blockquote><p>(3). 存取器</p></blockquote><p>使用 <code>getter</code> 和 <code>setter</code> 可以改变属性的赋值和读取:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return &apos;lisi&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value) &#123;</span><br><span class="line">        console.log(&apos;setter: &apos; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newStudent = new Student(&quot;zhangsan&quot;); // setter: zhangsan</span><br><span class="line">newStudent.name = &quot;wangwu&quot;; // setter: wangwu</span><br><span class="line">console.log(newStudent.name); // lisi</span><br></pre></td></tr></table></figure></p><h4 id="2-TypeScript中类的用法"><a href="#2-TypeScript中类的用法" class="headerlink" title="2. TypeScript中类的用法"></a>2. TypeScript中类的用法</h4><blockquote><p>(1). 修饰符</p></blockquote><p>TypeScript 可以使用三种访问修饰符，分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><p>使用 <code>public</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    public constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 = new Student(&quot;zhangsan&quot;);</span><br><span class="line">console.log(s1.name); // zhangsan</span><br><span class="line">s1.name = &apos;lisi&apos;;</span><br><span class="line">console.log(s1.name); // lisi</span><br></pre></td></tr></table></figure></p><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    public constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 = new Student(&quot;zhangsan&quot;);</span><br><span class="line">console.log(s1.name); //报错： 属性“name”为私有属性，只能在类“Student”中访问</span><br><span class="line">s1.name = &apos;lisi&apos;;</span><br></pre></td></tr></table></figure></p><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Dad &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        console.log(`im your dad`);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `我是你$&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Dad &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name); </span><br><span class="line">        console.log(this.name); //报错： 属性“name”为私有属性，只能在类“Dad”中访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Dad &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Dad &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name); //可以访问父级</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>(2). 参数属性</p></blockquote><p>修饰符和 <code>readonly</code> 还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">// public name: string;</span><br><span class="line">public constructor(public name:string) &#123;</span><br><span class="line">    // this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>(3).  readonly</p></blockquote><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    readonly name: string;</span><br><span class="line">    public constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 = new Student(&quot;zhangsan&quot;);</span><br><span class="line">console.log(s1.name); // zhangsan</span><br><span class="line">s1.name = &quot;lisi”; //报错：无法分配到 &quot;name&quot; ，因为它是只读属性</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;TypeScript  的核心之一 就是对值（数据）所具有的结构进行类型检查、类型的约定、除了基本类型的检查，还有就是接口，用接口来进行标注
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://gengaiwei.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://gengaiwei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 使用qs</title>
    <link href="http://gengaiwei.com/2020/07/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8qs/"/>
    <id>http://gengaiwei.com/2020/07/23/微信小程序-使用qs/</id>
    <published>2020-07-23T10:25:49.000Z</published>
    <updated>2020-07-24T07:27:55.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="（待整理）"><a href="#（待整理）" class="headerlink" title="（待整理）"></a>（待整理）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;（待整理）&quot;&gt;&lt;a href=&quot;#（待整理）&quot; class=&quot;headerlink&quot; title=&quot;（待整理）&quot;&gt;&lt;/a&gt;（待整理）&lt;/h3&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信小程序 一些开发技巧</title>
    <link href="http://gengaiwei.com/2020/07/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://gengaiwei.com/2020/07/23/微信小程序-一些开发技巧/</id>
    <published>2020-07-23T08:24:33.000Z</published>
    <updated>2020-07-24T07:27:51.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-·-一些开发技巧-（待整理）"><a href="#微信小程序-·-一些开发技巧-（待整理）" class="headerlink" title="微信小程序 · 一些开发技巧 （待整理）"></a>微信小程序 · 一些开发技巧 （待整理）</h3><blockquote><p>input输入框输入数字时 只能输入小数点后两位 </p></blockquote><figure class="highlight plain"><figcaption><span>function(e) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  var value = e.detail.value;</span><br><span class="line">  var index = value.indexOf(&quot;.&quot;);</span><br><span class="line">  if (index == -1) &#123;</span><br><span class="line">    if (value.length &gt; 4) &#123;</span><br><span class="line">      value = value.substring(0, 4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (value.length - 3 &gt; index) &#123;</span><br><span class="line">      value = value.substring(0, index + 3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    tempBonus: value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-·-一些开发技巧-（待整理）&quot;&gt;&lt;a href=&quot;#微信小程序-·-一些开发技巧-（待整理）&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 · 一些开发技巧 （待整理）&quot;&gt;&lt;/a&gt;微信小程序 · 一些开发技巧 （待整理）&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 如何更新上一页数据</title>
    <link href="http://gengaiwei.com/2020/07/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%8E%A7%E5%88%B6%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E4%B8%8A%E4%B8%80%E9%A1%B5%E6%95%B0%E6%8D%AE/"/>
    <id>http://gengaiwei.com/2020/07/22/微信小程序-控制是否更新上一页数据/</id>
    <published>2020-07-22T00:25:37.000Z</published>
    <updated>2020-07-24T07:27:58.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>是否更新上一页数据 （待整理）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">updateProData() &#123;</span><br><span class="line">  let pages = getCurrentPages(),</span><br><span class="line">    prevPage = pages[pages.length - 2]; //获取上一个页面</span><br><span class="line">  prevPage.setData(&#123; //修改上一个页面的变量</span><br><span class="line">    isRefreshList: true</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;是否更新上一页数据 （待整理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序  使用vscode编辑器开发</title>
    <link href="http://gengaiwei.com/2020/07/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://gengaiwei.com/2020/07/11/微信小程序-使用vscode编辑器开发/</id>
    <published>2020-07-11T10:52:50.000Z</published>
    <updated>2020-07-24T07:27:54.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用vscode编辑器开发微信小程序"><a href="#使用vscode编辑器开发微信小程序" class="headerlink" title="使用vscode编辑器开发微信小程序"></a>使用vscode编辑器开发微信小程序</h3><blockquote><p>推荐安装插件</p></blockquote><table><thead><tr><th style="text-align:center">插件名</th><th style="text-align:left">主要功能</th></tr></thead><tbody><tr><td style="text-align:center">minapp</td><td style="text-align:left">wxml格式化、标签与属性自动补全及各种智能补全、内置snippets、js高亮等等</td></tr><tr><td style="text-align:center">wechat-snippets</td><td style="text-align:left">Wxml、js、json代码片段模版进行代码辅助，代码片段自动完成，可以作为minapp插件的补充。</td></tr><tr><td style="text-align:center">vscode-wechat</td><td style="text-align:left">微信应用支持vscode</td></tr><tr><td style="text-align:center">Vscode wxml</td><td style="text-align:left">提供wxml语法支持及代码片段</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用vscode编辑器开发微信小程序&quot;&gt;&lt;a href=&quot;#使用vscode编辑器开发微信小程序&quot; class=&quot;headerlink&quot; title=&quot;使用vscode编辑器开发微信小程序&quot;&gt;&lt;/a&gt;使用vscode编辑器开发微信小程序&lt;/h3&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript（一）：认知与基础类型</title>
    <link href="http://gengaiwei.com/2020/07/08/TypeScript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AE%A4%E7%9F%A5%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <id>http://gengaiwei.com/2020/07/08/TypeScript（一）：认知与基础类型/</id>
    <published>2020-07-08T06:22:11.000Z</published>
    <updated>2020-07-24T07:50:49.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TypeScript（一）：认知与基础类型"><a href="#TypeScript（一）：认知与基础类型" class="headerlink" title="TypeScript（一）：认知与基础类型"></a>TypeScript（一）：认知与基础类型</h3><p><img style="display: block; margin: 0 auto;" src="1.png" alt=""></p><blockquote><p>一、关于 TypeScript</p></blockquote><p><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 是 JavaScript 的一个<code>超集</code>，主要提供了类型系统和对 <code>ES6</code> 的支持，由 Microsoft 开发，代码开源于 GitHub 上。此处是<a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">中文文档</a></p><p><img style="display: block; margin: 0 auto;" src="2.png" alt=""></p><blockquote><p>二、TypeScript 的优缺点</p></blockquote><p><img src="3.png" alt="优点"><br><img src="4.png" alt="缺点"></p><blockquote><p>三、安装与编译</p></blockquote><ol><li><p>安装：</p><pre><code>npm install -g typescript 或者cnpm install -g typescript 或者yarn global add typescript </code></pre></li><li><p>编译：<br> <code>tsc helloworld.ts =&gt; helloworld.js</code> ts 文件是不能直接运行的，能运行的是 <code>js</code> 文件</p></li><li><p>自动编译：</p><pre><code>tsc --init //生成 tsconfig.json 然后：终端 &gt; 运行任务 &gt; tsc 监视</code></pre></li></ol><blockquote><p>四、TypeScript 的基础类型</p></blockquote><p>为了使编写的代码更规范，更有利于维护，增加了类型校验，在typescript中主要有以下类型：<br><img src="5.png" alt="类型总结图"></p><ul><li>Boolean 类型<br><img src="6.jpeg" alt="Boolean"></li><li>Number 类型<br><img src="7.jpeg" alt="Number"></li><li>String 类型<br><img src="8.jpeg" alt="String"></li><li>Array 类型<br><img src="9.jpeg" alt="Array"></li><li>Tuple 类型<br>  数组一般由同种类型的值组成，但有时需要在单个变量中存储不同类型的值时,就可以使用元组。<br>  元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值：<br><img src="10.jpeg" alt="Tuple"></li><li>Enum 类型<br>  使用枚举我们可以定义一些带名字的常量，方便清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</li><li>数字枚举<br>  <img src="11.jpeg" alt="Enum"><br>  默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。<br>  也可以设置 NORTH 的初始值：<br>  <img src="12.jpeg" alt="数字枚举"></li><li><p>字符串枚举<br>  在字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。<br>  <img src="13.jpeg" alt="字符串枚举"></p></li><li><p>异构枚举<br>  异构枚举的成员值是数字和字符串的混合：<br><img src="14.jpeg" alt="异构枚举"></p></li><li><p>Any 类型<br>  在 TypeScript 中，任何类型都可以被归为 <code>any</code> 类型。这让 <code>any</code> 类型成为了类型系统的顶级类型（也被称作<code>全局超级类型</code>）。<br>  <img src="15.jpeg" alt="Any"></p><pre><code>在许多场景下过于宽松，所以使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。   </code></pre></li><li><p>Void 类型</p><p>当一个函数没有返回值时，其返回值类型是 void：<br><img src="16.jpeg" alt="Void"></p></li></ul><p>但声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：<br><code>let unusable: void = undefined;</code></p><ul><li><p>Null 和 Undefined 类型</p><pre><code>在TypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。</code></pre></li></ul><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变，但，如果你指定了–<code>strictNullChecks</code> <code>标记，null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</p><ul><li><p>Never 类型<br>  never 类型表示的是那些永不存在的值的类型。 例如：会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。<br><img src="17.jpeg" alt="Never"><br>  可以利用 never 类型的特性来实现全面性检查：<br><img src="18.jpeg" alt="全面性检查"><br>假如后来有一天你的同事修改了 <code>WhatF</code> 的类型</p><pre><code>type WhatF = string | number | boolean;</code></pre><p>  使用 never 避免出现新增联合类型没有对应的情况，使类型更加健壮。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TypeScript（一）：认知与基础类型&quot;&gt;&lt;a href=&quot;#TypeScript（一）：认知与基础类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript（一）：认知与基础类型&quot;&gt;&lt;/a&gt;TypeScript（一）：认知与基础类型&lt;/
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://gengaiwei.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://gengaiwei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 使用 NPM</title>
    <link href="http://gengaiwei.com/2020/07/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8-NPM/"/>
    <id>http://gengaiwei.com/2020/07/07/微信小程序-使用-NPM/</id>
    <published>2020-07-07T10:59:00.000Z</published>
    <updated>2020-07-20T02:45:20.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、微信小程序-·-使用-NPM"><a href="#一、微信小程序-·-使用-NPM" class="headerlink" title="一、微信小程序 · 使用 NPM"></a>一、微信小程序 · 使用 NPM</h3><blockquote><p>一、如果按文档走：</p></blockquote><pre><code>执行命令安装： npm install工具 -&gt; 构建 npm</code></pre><p>⚠️ 没有找到 node_modules 目录的话：是由于npm 还没有初始化</p><blockquote><p>二、解决如下：</p></blockquote><ol><li><p>在小程序根目录下执行命令：</p><pre><code>npm init  生成 package.json文件</code></pre></li><li><p>在继续安装你要安装的第三方包：</p><pre><code>npm i vant-weapp -S --production</code></pre></li><li><p>开发工具</p><pre><code>工具 -&gt; 构建 npm</code></pre></li><li><p>详情里面</p><pre><code>选中使用 npm 模块</code></pre></li><li><p>改 app.json</p><pre><code>将 app.json 中的 &quot;style&quot;: &quot;v2&quot; 去除，小程序的新版基础组件强行加上了许多样式，难以去除，不关闭将造成部分组件样式混乱。</code></pre></li></ol><blockquote><p> 三、应用：</p></blockquote><pre><code>// 通过 npm 安装// app.json&quot;usingComponents&quot;: {&quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;}// 通过下载源码使用 es6版本// app.json&quot;usingComponents&quot;: {&quot;van-button&quot;: &quot;path/to/@vant/weapp/dist/button/index&quot;}// 通过下载源码使用 es5版本// app.json&quot;usingComponents&quot;: {&quot;van-button&quot;: &quot;path/to/@vant/weapp/lib/button/index&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、微信小程序-·-使用-NPM&quot;&gt;&lt;a href=&quot;#一、微信小程序-·-使用-NPM&quot; class=&quot;headerlink&quot; title=&quot;一、微信小程序 · 使用 NPM&quot;&gt;&lt;/a&gt;一、微信小程序 · 使用 NPM&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 App.js写点什么</title>
    <link href="http://gengaiwei.com/2020/06/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-app-js%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/"/>
    <id>http://gengaiwei.com/2020/06/20/微信小程序-app-js写点什么/</id>
    <published>2020-06-20T10:45:28.000Z</published>
    <updated>2020-07-24T07:27:50.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 版本更新提示 （待整理）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const updateManager = wx.getUpdateManager()</span><br><span class="line">updateManager.onUpdateReady(function() &#123;</span><br><span class="line">  wx.showModal(&#123; </span><br><span class="line">    title: &apos;更新提示&apos;,</span><br><span class="line">    content: &apos;新版本已经准备好，是否重启应用？&apos;,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      if (res.confirm) &#123;</span><br><span class="line">        updateManager.applyUpdate();// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>（待整理）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 版本更新提示 （待整理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 使用全局CSS</title>
    <link href="http://gengaiwei.com/2020/05/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A8%E5%B1%80CSS/"/>
    <id>http://gengaiwei.com/2020/05/04/微信小程序全局CSS/</id>
    <published>2020-05-04T10:45:12.000Z</published>
    <updated>2020-07-24T04:29:41.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-·-使用全局CSS"><a href="#微信小程序-·-使用全局CSS" class="headerlink" title="微信小程序 · 使用全局CSS"></a>微信小程序 · 使用全局CSS</h3><blockquote><p>1、使用全局的app.css</p></blockquote><ul><li>app.wxss 是全局样式文件，对每个页面都起作用 如果某个页面不想要这个样式可以在那个页面再单独定义样式覆盖全局默认样式;</li><li>微信小程序样式可以 <code>@import</code>其他样式文件;</li><li>微信小程序样式 和 CSS 一样;</li><li>支持常用的 <code>:after,:before</code>, :<code>first-child</code> , <code>nth-child</code> 等常用伪劣选择器.</li></ul><blockquote><p>2、引入其他样式文件</p></blockquote><pre><code>使用 @import 导入外联样式表，@import 使用 外联样式表的相对路径在公共文件中创建demo.wxss文件后直接在所需要引入的wxss文件中引入 或者在app.wxss中引入@import &quot;demo.wxss“;</code></pre><blockquote><p>3、常用支持的选择器</p></blockquote><table><thead><tr><th>选择器</th><th style="text-align:center">demo</th></tr></thead><tbody><tr><td>类选择器</td><td style="text-align:center">.class</td></tr><tr><td>ID选择器</td><td style="text-align:center">#id</td></tr><tr><td>标签选择器</td><td style="text-align:center">view</td></tr><tr><td>后代选择器</td><td style="text-align:center">.class .child-class</td></tr><tr><td>:after</td><td style="text-align:center">view:after</td></tr><tr><td>:before</td><td style="text-align:center">view:before</td></tr><tr><td>:first-child</td><td style="text-align:center">view:first-child</td></tr><tr><td>:last-child</td><td style="text-align:center">view:last-child</td></tr><tr><td>:nth-child</td><td style="text-align:center">view:nth-child(even) view:nth-child(odd)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-·-使用全局CSS&quot;&gt;&lt;a href=&quot;#微信小程序-·-使用全局CSS&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 · 使用全局CSS&quot;&gt;&lt;/a&gt;微信小程序 · 使用全局CSS&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、使用全
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 下载查看PDF</title>
    <link href="http://gengaiwei.com/2020/03/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%B8%8B%E8%BD%BD%E6%9F%A5%E7%9C%8BPDF/"/>
    <id>http://gengaiwei.com/2020/03/10/微信小程序-下载查看PDF/</id>
    <published>2020-03-10T11:17:07.000Z</published>
    <updated>2020-07-24T04:40:54.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="待发布"><a href="#待发布" class="headerlink" title="待发布"></a>待发布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">checkPDF: function () &#123;</span><br><span class="line">  wx.downloadFile(&#123;</span><br><span class="line">    url: &apos;https://***.png&apos;,      //要预览的PDF的地址</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">      if (res.statusCode === 200) &#123;                     //成功</span><br><span class="line">        var Path = res.tempFilePath                     //返回的文件临时地址，用于后面打开本地预览所用</span><br><span class="line">        wx.openDocument(&#123;</span><br><span class="line">          filePath: Path,                               //要打开的文件路径</span><br><span class="line">          success: function (res) &#123;</span><br><span class="line">            console.log(&apos;打开PDF成功&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function (res) &#123;</span><br><span class="line">      console.log(res);                                  //失败</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;待发布&quot;&gt;&lt;a href=&quot;#待发布&quot; class=&quot;headerlink&quot; title=&quot;待发布&quot;&gt;&lt;/a&gt;待发布&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 支付功能</title>
    <link href="http://gengaiwei.com/2020/02/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/"/>
    <id>http://gengaiwei.com/2020/02/20/微信小程序-支付功能/</id>
    <published>2020-02-20T10:59:29.000Z</published>
    <updated>2020-07-20T09:14:30.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-使用支付功能"><a href="#微信小程序-使用支付功能" class="headerlink" title="微信小程序 使用支付功能"></a>微信小程序 使用支付功能</h3><p>步骤如下：</p><blockquote><p>需要 openid  由登录API code 换取 </p></blockquote><p>此 openid 通过 <code>wx.login</code> 获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  success: res =&gt; &#123;</span><br><span class="line">    // 发送 res.code 到后台换取 openId, sessionKey, unionId</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>数据签名：五个必填字段签名(区分大小写) 需要后台接口返回以下数据</p></blockquote><ul><li>timeStamp   时间戳  从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间</li><li>nonceStr 随机字符串， 长度为32个字符以下 </li><li>Package  数据包 统一下单接口返回的 prepay_id 参数值 提交格式如：prepay_id=***</li><li>signType 签名算法  默认 “MD5”</li><li>paySign  签名 </li></ul><p>实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.requestPayment(&#123;</span><br><span class="line">  timeStamp: &apos;&apos;,</span><br><span class="line">  nonceStr: &apos;&apos;,</span><br><span class="line">  package: &apos;&apos;,</span><br><span class="line">  signType: &apos;MD5&apos;,</span><br><span class="line">  paySign: &apos;&apos;,</span><br><span class="line">  success (res) &#123; &#125;,</span><br><span class="line">  fail (res) &#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>调起支付页面的协议需要是 <code>https</code></p></blockquote><table><tr><td bgcolor="pink"><em>注 ：使用前提 首先需要在公众平台开通申请 微信支付 而且需要小程序已发布上线或者有已经关联的线上公众号、小程序</em></td></tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-使用支付功能&quot;&gt;&lt;a href=&quot;#微信小程序-使用支付功能&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 使用支付功能&quot;&gt;&lt;/a&gt;微信小程序 使用支付功能&lt;/h3&gt;&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要 o
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>Vue Cli 3.x项目构建与开发</title>
    <link href="http://gengaiwei.com/2020/02/01/vueproject/"/>
    <id>http://gengaiwei.com/2020/02/01/vueproject/</id>
    <published>2020-02-01T03:05:25.000Z</published>
    <updated>2020-07-20T03:18:14.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue-Cli-3-x-项目构建与开发"><a href="#Vue-Cli-3-x-项目构建与开发" class="headerlink" title="Vue Cli 3.x 项目构建与开发"></a>Vue Cli 3.x 项目构建与开发</h3><p>这里是<a href="https://github.com/DavidGAW/vue-cli3.x-test" target="_blank" rel="noopener">GitHub项目地址</a></p><h4 id="一、脚手架-CLI-的理解"><a href="#一、脚手架-CLI-的理解" class="headerlink" title="一、脚手架 CLI 的理解"></a>一、脚手架 CLI 的理解</h4><blockquote><p>脚手架 CLI，是一个命令行工具，它的出现主要解决这几个问题：</p></blockquote><ul><li>减少重复性工作</li><li>规范项目开发目录结构</li><li>统一团队统一开发风格，便于跨团队合作，以及后期维护，降低新人上手成本</li><li>提供一键前端项目的创建、配置、本地开发、插件扩展等功能，让开发者更多时间专注于业务</li></ul><h4 id="二、CLI的基本功能"><a href="#二、CLI的基本功能" class="headerlink" title="二、CLI的基本功能"></a>二、CLI的基本功能</h4><blockquote><p>搭建项目</p></blockquote><ul><li>根据用户输入生成配置文件</li><li>下载指定项目模板</li><li>在目标目录生成新项目</li></ul><blockquote><p>运行项目</p></blockquote><ul><li>本地启动预览</li><li>热更新</li><li>语法、代码规范检测</li><li>代码推送至仓库</li><li>前端部署的管理后台去进行发布（自动打包）</li></ul><h4 id="三、CLI的安装"><a href="#三、CLI的安装" class="headerlink" title="三、CLI的安装"></a>三、CLI的安装</h4><p>这里选择的是自定义安装：</p><ul><li>依赖工具：node、 npm    </li><li>安装 Vue CLI 3.x命令 ：npm i -g @vue/cli</li><li>构建 vue create my-project</li><li>可选默认 / 推荐自定义 TS、 Babel、Router、 Vuex、CSS Pre-processors 等</li></ul><p>示例如下：</p><p><img src="1.png" alt=""><br><img src="2.png" alt=""><br><em>注：除上述命令构建外 还可用 vue ui 可视化 进行构建</em><br>生成目录 （选择的配置不同目录也会有差异）<br><img src="3.png" alt=""></p><h3 id="四、NPM包管理与配置项"><a href="#四、NPM包管理与配置项" class="headerlink" title="四、NPM包管理与配置项"></a>四、NPM包管理与配置项</h3><ol><li><p>配置项：一系列键值对构成的 JSON 对象，每一个键值对都有其相应的作用</p></li><li><p>包管理常用命令：<code>npm init</code>、<code>npm init -y</code>、<code>npm i</code>、<code>npm i xxx</code>、<code>npm i xxx —-save</code>、<code>npm i xxx --save-dev</code>、<code>npm i -g xxx</code>、<code>npm run xxx</code></p></li><li><p><code>vue-cli 3.x</code> 还提供了其专属的 <code>vue ad</code>d 命令：以<code>@vue/cli-plugin</code> 或者 <code>vue-cli-plugin</code> 开头， 只能安装 Vue 集成的包（两个特例：<code>vue add router</code>、<code>vue add vuex</code>），同时， <code>vue add</code> 不仅会将包安装到你的项目中，其还会改变项目的代码或文件结构，所以安装前最好提交你的代码至仓库</p></li></ol><h3 id="五、webpack在cli3-x"><a href="#五、webpack在cli3-x" class="headerlink" title="五、webpack在cli3.x"></a>五、webpack在cli3.x</h3><ol><li>与cli2.x中的差异<br><img src="4.png" alt=""></li><li>开箱即用，无需配置 webpack 就可以运行项目，并且提供了 vue.config.js 文件来满足开发者对其封装的 webpack 默认配置的修改 如果项目目录中没有此文件 新建即可；<br><img src="5.png" alt=""><br><em>参考：<a href="https://github.com/vuejs/vue-cli/blob/ce3e2d475d63895cbb40f62425bb6b3237469bcd/docs/zh/config/README.md" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/blob/ce3e2d475d63895cbb40f62425bb6b3237469bcd/docs/zh/config/README.md</a></em></li><li>默认插件：vue-cli 3.x 为我们默认封装了项目运行的常用 webpack 配置，它给我们提供了默认插件，每一个 plugin的用途 除了使用 vue inspect plugins  查看 还可以通过运行 vue ui 进入可视化页面查看(tasks =&gt;inspect=&gt;run task)</li></ol><figure class="highlight plain"><figcaption><span>vue-loader是 webpack 的加载器，允许你以单文件组件的格式编写 Vue 组件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin’);</span><br><span class="line">// webpack 内置插件，用于创建在编译时可以配置的全局常量</span><br><span class="line">const &#123; DefinePlugin &#125; = require(&apos;webpack’);</span><br><span class="line">// 用于强制所有模块的完整路径必需与磁盘上实际路径的确切大小写相匹配</span><br><span class="line">const CaseSensitivePathsPlugin = require(&apos;case-sensitive-paths-webpack-plugin’);</span><br><span class="line">// 识别某些类型的 webpack 错误并整理，以提供开发人员更好的体验。</span><br><span class="line">const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;); </span><br><span class="line">// 用于根据模板或使用加载器生成 HTML 文件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin’);</span><br><span class="line">// 用于在使用 html-webpack-plugin 生成的 html 中添加 &lt;link rel =&apos;preload&apos;&gt; 或 &lt;link rel =&apos;prefetch&apos;&gt;，有助于异步加载</span><br><span class="line">const PreloadPlugin = require(&apos;preload-webpack-plugin&apos;);</span><br></pre></td></tr></table></figure><h3 id="六、env文件与环境配置"><a href="#六、env文件与环境配置" class="headerlink" title="六、env文件与环境配置"></a>六、env文件与环境配置</h3><blockquote><p>在实际项目的开发中一般会经历项目的开发阶段、测试阶段和最终上线阶段，每一个阶段对于项目代码的要求可能都不尽相同，那么我们如何能够游刃有余的在不同阶段下使我们的项目呈现不同的效果，使用不同的功能呢？这里就需要引入环境的概念。</p></blockquote><p>一般一个项目都会有以下 3 种环境：</p><ul><li>开发环境（开发阶段，本地开发版本，一般会使用一些调试工具或额外的辅助功能）</li><li>测试环境（测试阶段，上线前版本，除了一些 bug 的修复，基本不会和上线版本有很大差别）</li><li>生产环境（上线阶段，正式对外发布的版本，一般会进行优化，关掉错误报告）</li></ul><h5 id="6-1-如何配置"><a href="#6-1-如何配置" class="headerlink" title="6.1 如何配置"></a>6.1 如何配置</h5><blockquote><p>默认在配置之前 需要清楚配置的环境关系<br>生产环境配置、开发环境配置、测试环境配置、公共配置<br>存在交集 也就是有公共配置 那么如何处理：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env # 在所有的环境中被载入</span><br><span class="line">.env.local# 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode] # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p>比如我们创建一个名为 .env.stage 的文件，该文件表明其只在 stage 环境下被加载，在这个文件中，我们可以配置如下键值对的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage </span><br><span class="line">VUE_APP_TITLE=stage mode</span><br></pre></td></tr></table></figure></p><p>然后在修改 package.json 中的 serve 脚本的命令为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;vue-cli-service serve --mode stage&quot;</span><br></pre></td></tr></table></figure></p><p>其实是修改了 webpack 4 中的 mode 配置项为 stage，同时其会读取对应 .env.[model] 文件下的配置，如果没找到对应配置文件，就会用默认环境 development </p><h5 id="6-2-环境注入"><a href="#6-2-环境注入" class="headerlink" title="6.2 环境注入"></a>6.2 环境注入</h5><blockquote><p>vue-cli 3.x 封装的 webpack 配置中已经完成了这个功能，所以我们可以直接在客户端代码中打印出 process.env 的值</p></blockquote><p><img src="6.png" alt=""></p><p>输出内容除了我们环境配置中的变量外还包含了很多 npm 的信息，但是我们在入口文件 main.js 中打印会发现输出</p><p><img src="7.png" alt=""><br>过滤调了非 VUE_APP_ 开头的变量 是因为webpack 通过 DefinePlugin 内置插件将 process.env 注入到客户端代码中。</p><h5 id="6-3-额外配置"><a href="#6-3-额外配置" class="headerlink" title="6.3 额外配置"></a>6.3 额外配置</h5><blockquote><p>以上通过新建配置文件的方式为项目不同环境配置不同的变量值，能够实现项目基本的环境管理，但是 .env 这样的配置文件中的参数目前只支持静态值，无法使用动态参数，当需要实现特定的需求时（如在非生产环境我们可以给自己的移动端项目开启 vConsole 调试/配置中的 BASE_URL 来设置路由的 base 参数），可以在根目录下新建 config 文件夹用于存放一些额外的配置文件。</p></blockquote><p><img src="8.png" alt=""></p><p>把环境变量分为了公共变量、开发环境变量和生产环境变量，当然这些变量可能是动态的，比如门店/用户的IP 等。现在我们要在 vue.config.js 里注入这些变量，我们可以使用 chainWebpack 修改 DefinePlugin 中的值：</p><p><img src="9.png" alt=""></p><p>成功打印</p><p><img src="10.png" alt=""></p><p>环境的配置和管理对于项目的构建起到了至关重要的作用，通过给项目配置不同的环境不仅可以增加开发的灵活性、提高程序的拓展性，同时也有助于帮助我们去了解并分析项目在不同环境下的运行机制，建立全局观念。</p><h3 id="七、页面内部配置"><a href="#七、页面内部配置" class="headerlink" title="七、页面内部配置"></a>七、页面内部配置</h3><blockquote><p>前面部分主要说的是项目构建及运行的前期工作，像webpack 的配置、环境变量的使用等，接下来，走进vue项目的内部，理解内部配置的基本构成。</p></blockquote><p><img src="11.png" alt=""></p><h5 id="7-1-Vue-基本配置：-路由配置-src-gt-router-gt-index-js"><a href="#7-1-Vue-基本配置：-路由配置-src-gt-router-gt-index-js" class="headerlink" title="7.1 Vue 基本配置： 路由配置 src -&gt; router -&gt; index.js"></a>7.1 Vue 基本配置： 路由配置 src -&gt; router -&gt; index.js</h5><p>最基础的路由配置，有以下几点需要进行优化：</p><ul><li>如果路由存在二级目录，需要添加 base 属性，否则默认为 “/“</li><li>默认路由模式是 hash 模式，会携带 # 标记，与真实 url 不符，可以改为 history 模式</li><li>页面组件没有进行按需加载，可以使用 require.ensure() 来进行优化、import 语法来进行代码分块、Magic Comments、</li></ul><h5 id="7-2-vuex-配置-src-gt-store-gt-index-js"><a href="#7-2-vuex-配置-src-gt-store-gt-index-js" class="headerlink" title="7.2 vuex 配置: src -&gt; store -&gt; index.js"></a>7.2 vuex 配置: src -&gt; store -&gt; index.js</h5><blockquote><p>专门为vuejs应用程序开发的状态管理模式 </p></blockquote><p>主要四个部分 ：<br>        <code>state</code> <code>mutations</code> <code>actions</code> <code>getter</code></p>  <table><tr><td bgcolor="orange">通过 actions 异步提交 mutations 去 修改 state 的值并通过 getter 获取。</td></tr></table><p>vuex适合中大型项目，用来管理错综复杂的状态数据是很有帮助的，而为了后期的拓展性和可维护性，不建议使用 CLI 生成的一份配置文件来管理所有的状态操作，我们可以把它拆分为以下目录：</p><p><img src="12.png" alt=""></p><p><em>项目中状态的模块划分就更加清晰，对应模块的状态我们只需要修改相应模块文件即可</em></p><h5 id="7-3-接口配置-src-gt-services-gt-http-js-etc"><a href="#7-3-接口配置-src-gt-services-gt-http-js-etc" class="headerlink" title="7.3 接口配置:src -&gt; services -&gt; http.js etc"></a>7.3 接口配置:src -&gt; services -&gt; http.js etc</h5><blockquote><p>在 src 目录下新建 services 文件夹用于存放接口文件<br>并可以使用不同的文件来配置不同模块的接口，同时由于接口的调用 ajax 请求代码重复部分较多，可以对其进行简单的封装 =&gt;http.js</p></blockquote><h5 id="7-4-公共设施配置-src-gt-common-gt-index-js-validate-js-etc"><a href="#7-4-公共设施配置-src-gt-common-gt-index-js-validate-js-etc" class="headerlink" title="7.4 公共设施配置:src -&gt; common -&gt; index.js/validate.js etc"></a>7.4 公共设施配置:src -&gt; common -&gt; index.js/validate.js etc</h5><blockquote><p>在项目开发中肯定需要对一些公共的方法进行封装使用，这里把它称之为公共设施，那么我们可以在 src 目录下建一个 common 文件夹来存放其配置文件：<br>只需要在入口文件向外暴露其他功能配置的模块，在页面中只需要引入一个index.js 即可</p></blockquote><h3 id="八、开发工具的扩充"><a href="#八、开发工具的扩充" class="headerlink" title="八、开发工具的扩充"></a>八、开发工具的扩充</h3><p>1、vue.js devtools  </p><ul><li>作用： Vue 官方发布的一款调试 Vue 项目的插件，支持数据模拟与调试</li><li>安装：<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN</a></li></ul><p>2、Vue performance devtool</p><ul><li>作用： 可以分析我们页面中各个组件的性能情况，从而在其基础上我们可以有针对性的对组件的代码进行优化 </li><li>安装：<a href="https://chrome.google.com/webstore/detail/vue-performance-devtool/koljilikekcjfeecjefimopfffhkjbne" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/vue-performance-devtool/koljilikekcjfeecjefimopfffhkjbne</a></li></ul><p>3、FeHelper</p><ul><li>作用： 是百度 FE 团队开发的一款前端工具集插件，包含代码压缩／性能检测／字符串编解码等功能，能够帮助我们完成一些琐碎的开发任务。</li><li>安装：<a href="https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue-Cli-3-x-项目构建与开发&quot;&gt;&lt;a href=&quot;#Vue-Cli-3-x-项目构建与开发&quot; class=&quot;headerlink&quot; title=&quot;Vue Cli 3.x 项目构建与开发&quot;&gt;&lt;/a&gt;Vue Cli 3.x 项目构建与开发&lt;/h3&gt;&lt;p&gt;这里
      
    
    </summary>
    
      <category term="Vue" scheme="http://gengaiwei.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://gengaiwei.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>git分支使用</title>
    <link href="http://gengaiwei.com/2019/04/02/gitBranch/"/>
    <id>http://gengaiwei.com/2019/04/02/gitBranch/</id>
    <published>2019-04-02T12:46:03.000Z</published>
    <updated>2019-12-03T09:30:14.729Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Git" scheme="http://gengaiwei.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hi Man</title>
    <link href="http://gengaiwei.com/2018/10/11/hello-world/"/>
    <id>http://gengaiwei.com/2018/10/11/hello-world/</id>
    <published>2018-10-11T07:20:30.796Z</published>
    <updated>2018-10-11T07:20:30.797Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img src="/h.png" alt="Alt text"></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://gengaiwei.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 分类 提交后台返回的分类ID</title>
    <link href="http://gengaiwei.com/2018/03/10/wxPicker/"/>
    <id>http://gengaiwei.com/2018/03/10/wxPicker/</id>
    <published>2018-03-10T06:40:49.000Z</published>
    <updated>2020-07-20T02:45:29.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="底部弹出分类选项，选中之后，得到后台返回的ID，这里是GitHub"><a href="#底部弹出分类选项，选中之后，得到后台返回的ID，这里是GitHub" class="headerlink" title="底部弹出分类选项，选中之后，得到后台返回的ID，这里是GitHub"></a>底部弹出分类选项，选中之后，得到后台返回的ID，这里是<a href="https://github.com/DavidGAW/wx-picker" target="_blank" rel="noopener">GitHub</a></h3><blockquote><p>1.wxml</p></blockquote><pre><code>&lt;picker  bindchange=&quot;bindCategory&quot;  name=&quot;category_id&quot; value=&quot;{{category_index}}&quot; range=&quot;{{category}}&quot; &gt;    &lt;view class=&quot;picker&quot; &gt;        &lt;text style=&apos;color:#888;padding-right:5%;&apos;&gt;分类&lt;/text&gt;{{category[category_index]}}    &lt;/view&gt;    &lt;image class=&apos;dowm-btn&apos; src=&apos;一个向下箭头的图片&apos;&gt;&lt;/image&gt;&lt;/picker&gt;</code></pre><blockquote><p>2.wxss</p></blockquote><pre><code>.fl{background: #fff;height: 45px;line-height: 45px;padding-left: 5%;font-size: 0.8rem;}.picker{width: 85%;display: inline-block;}.dowm-btn{width: 1rem;height: 1rem;vertical-align: middle;}</code></pre><blockquote><p>3.js 这里只是得到了选中的本身自带的ID，可能并不是后台给你的ID</p></blockquote><pre><code>bindCategory: function (e) {    var that =this    that.setData({    category_index: e.detail.value    })},</code></pre><blockquote><p>4.一般的选择分类，一般都是包含在一个大的表单里，要提交到后台提供的接口里，So ,wxml</p></blockquote><pre><code>&lt;form bindsubmit=&apos;submitForm&apos;&gt;//这里包含各种表单，for example：input ,checkbox ,radio etc.&lt;picker  bindchange=&quot;bindCategory&quot;  name=&quot;category_id&quot; value=&quot;{{category_index}}&quot; range=&quot;{{category}}&quot; &gt;    &lt;view class=&quot;picker&quot; &gt;        &lt;text style=&apos;color:#888;padding-right:5%;&apos;&gt;分类&lt;/text&gt;{{category[category_index]}}    &lt;/view&gt;    &lt;image class=&apos;dowm-btn&apos; src=&apos;一个向下箭头的图片&apos;&gt;&lt;/image&gt;&lt;/picker&gt;&lt;view class=&apos;submitForm&apos;&gt;    &lt;button class=&apos;submitbtn&apos; form-type=&apos;submit&apos; &gt;发布&lt;/button&gt;&lt;/view&gt;&lt;/form&gt;</code></pre><blockquote><p>5.选取分类，得到的ID是当前标签本身的index，并不是后台返回的ID，So,在分类的接口回调中，把分类的name与ID分别存下来，然后，在提交表单的时候，把当前分类自带的ID替换为后台提供的ID</p></blockquote><pre><code>//分类接口wx.request({url: ‘分类接口&apos;,method: &apos;GET&apos;,header: {    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,    Token: wx.getStorageSync(&apos;openid&apos;),//    Accept: &apos;application/vnd.epet.v1+json&apos;,},success: function (res) {    let category = res.data.data    var id_arr=[];    var name_arr = [];    for (var i = 0; i &lt; category.length; i++) {    id_arr[i] = category[i].id    name_arr[i] = category[i].name;    }    that.setData({    category: name_arr,    category_idlist: id_arr    });},fail: function (res) {    wx.hideLoading();    wx.showToast({    title: &apos;加载失败&apos;,    icon: &apos;err&apos;,    duration: 2000    });}});</code></pre><blockquote><p>6.在提交表单时，更换为后台提供的分类对应的ID</p></blockquote><pre><code>// 上传所有数据===========submitForm: function (e) {    var that = this    e.detail.value.category_id = that.data.category_idlist[e.detail.value.category_id]    console.log(e.detail.value.category_id)    wx.request({    url: ‘提交表单的接口&apos;,    method: &apos;POST&apos;,    data: {               category_id: e.detail.value.category_id,    },    header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,        Token: wx.getStorageSync(&apos;openid&apos;),        Accept: &apos;application/vnd.epet.v1+json&apos;,    },    success: function (res) {        console.log(res)    },    fail: function (res) {    }    });},</code></pre><blockquote><p>如果对你有用，谢谢 Star一下<a href="https://github.com/DavidGAW/wx-picker" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;底部弹出分类选项，选中之后，得到后台返回的ID，这里是GitHub&quot;&gt;&lt;a href=&quot;#底部弹出分类选项，选中之后，得到后台返回的ID，这里是GitHub&quot; class=&quot;headerlink&quot; title=&quot;底部弹出分类选项，选中之后，得到后台返回的ID，这里
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 轮播图/跑马灯</title>
    <link href="http://gengaiwei.com/2018/03/08/wxSwiper/"/>
    <id>http://gengaiwei.com/2018/03/08/wxSwiper/</id>
    <published>2018-03-08T08:20:14.000Z</published>
    <updated>2020-07-20T02:45:27.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动"><a href="#Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动" class="headerlink" title="Swiper 轮播图 也可做成跑马灯 就像信息提示/公告 在这里都是左右滚动"></a>Swiper 轮播图 也可做成跑马灯 就像信息提示/公告 在这里都是左右滚动</h3><blockquote><p>1.swiper 轮播图 wxml</p></blockquote><pre><code>&lt;view class=&apos;lunBo&apos;&gt;    &lt;swiper class=&apos;swiper&apos; indicator-dots=&apos;true&apos; autoplay=&apos;true&apos; interval=&apos;3000&apos; duration=&apos; 200&apos; circular=&apos;true&apos;&gt;        &lt;block wx:for=&quot;{{lunBoimgUrls}}&quot; wx:key=&quot;&quot;&gt;            &lt;swiper-item&gt;                &lt;image src=&quot;{{item}}&quot; class=&quot;lunBo-image&quot; /&gt;            &lt;/swiper-item&gt;        &lt;/block&gt;    &lt;/swiper&gt;&lt;/view&gt;</code></pre><blockquote><p>2.swiper 跑马灯 wxml</p></blockquote><pre><code>&lt;!--跑马灯  --&gt;&lt;view class=&apos;share-tips&apos;&gt;    &lt;view class=&apos;my-center&apos;&gt;        &lt;text class=&apos;tips-f&apos;&gt;公告：&lt;/text&gt;         &lt;swiper class=&apos;tips-k&apos;  autoplay  interval=&apos;5000&apos; duration=&apos;3000&apos; circular=&apos;true&apos; &gt;            &lt;swiper-item wx:key=&quot;&quot; wx:for=&apos;{{tipsText}}&apos;&gt;                &lt;view&gt;{{item}}&lt;/view&gt;            &lt;/swiper-item&gt;        &lt;/swiper&gt;    &lt;/view&gt;&lt;/view&gt;</code></pre><blockquote><p>3.swiper 轮播图/跑马灯 wxss</p></blockquote><pre><code>.lunBo-k{height: 0px;}.lunBo{position: absolute;top:-54px;left: 0px;width: 100%;height: 158px;border-radius: 8px;}.lunBo swiper {height: 100%;}.lunBo swiper swiper-item{width: 100%;border-radius: 8px; }.lunBo-image{width: 100%;height: 158px; border-radius: 8px; }.tips-f{width: 20%;font-size: 0.6rem;height: 24px;line-height: 24px;float: left;}.tips-k{width: 80%;height: 24px;overflow: hidden;font-size: 12px;display: inline-block;}</code></pre><blockquote><p>4.swiper 轮播图/跑马灯 js</p></blockquote><pre><code>data: {    lunBoimgUrls: [    &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&apos;,    &apos;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&apos;,    &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg&apos;,    ],    tipsText: [    &apos;我是第一条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    &apos;我是第二条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    &apos;我是第三条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    ],},</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动&quot;&gt;&lt;a href=&quot;#Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动&quot; class=&quot;headerlink&quot; title=&quot;Swiper 轮播图 也可做成跑
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 评论留言功能</title>
    <link href="http://gengaiwei.com/2018/03/06/wx-comment/"/>
    <id>http://gengaiwei.com/2018/03/06/wx-comment/</id>
    <published>2018-03-06T06:52:24.000Z</published>
    <updated>2020-07-20T02:45:36.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-评论留言功能"><a href="#微信小程序-评论留言功能" class="headerlink" title="微信小程序 评论留言功能"></a>微信小程序 评论留言功能</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-评论留言功能&quot;&gt;&lt;a href=&quot;#微信小程序-评论留言功能&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 评论留言功能&quot;&gt;&lt;/a&gt;微信小程序 评论留言功能&lt;/h3&gt;
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 下拉刷新 上拉加载</title>
    <link href="http://gengaiwei.com/2018/03/05/wx-onPullDownRefresh-onReachBottom/"/>
    <id>http://gengaiwei.com/2018/03/05/wx-onPullDownRefresh-onReachBottom/</id>
    <published>2018-03-05T09:36:08.000Z</published>
    <updated>2020-07-20T02:45:32.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh-onReachBottom"><a href="#微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh-onReachBottom" class="headerlink" title="微信小程序的上拉下滑，第一次展示的数据是在onLoad中 执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh/onReachBottom"></a>微信小程序的上拉下滑，第一次展示的数据是在onLoad中 执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh/onReachBottom</h3><blockquote><p>1.初次渲染数据列表</p></blockquote><pre><code>wx.request({    url: &apos;your url&apos;,    method: &apos;GET&apos;,    header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,        Accept: &apos;application/vnd.epet.v1+json&apos;,    },    success: function (res) {        console.log(res)        let shareData = res.data.data        let meta = res.data.meta        that.setData({        shareData: shareData,        meta: meta, //后台        });        if (res.statusCode == 200) {        wx.hideLoading();        } else {        wx.hideLoading();        wx.showToast({            title: &apos;加载失败&apos;,            duration: 0,            mask: true,            success: function (res) { },        })        }    },    fail: function (res) {        wx.hideLoading();        wx.showToast({        title: &apos;加载失败&apos;,        icon: &apos;err&apos;,        duration: 2000        });    }});</code></pre><blockquote><p>2.上拉拉到第一页，调用后台接口，返回第一页数据列表</p></blockquote><pre><code>onPullDownRefresh: function () {    let that = this;    wx.showNavigationBarLoading();    wx.request({    url: &apos;your-url?page=1&apos;,    method: &apos;GET&apos;,    header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,        Token: wx.getStorageSync(&apos;openid&apos;),        Accept: &apos;application/vnd.epet.v1+json&apos;,    },    success: function (res) {        console.log(res)        let shareData = res.data.data        that.setData({        shareData: shareData        });        if (res.statusCode == 200) {        wx.hideLoading();        } else {        wx.hideLoading();        wx.showToast({            title: &apos;加载失败&apos;,            duration: 0,            mask: true,            success: function (res) { },        })        }    },    fail: function (res) {        wx.hideLoading();        wx.showToast({        title: &apos;加载失败&apos;,        icon: &apos;err&apos;,        duration: 2000        });    }    });},</code></pre><blockquote><p>3.下滑，有的是后台返回页数，然后前端进行计算，或者后台在接口里是链接，这样直接判断链接</p></blockquote><pre><code>onReachBottom: function () {    let that = this;    wx.showLoading({    title: &apos;加载中...&apos;,    })    console.log(that.data.meta.pagination.links.next)    if (that.data.meta.pagination.links.next) {    wx.request({        url: that.data.meta.pagination.links.next,        method: &apos;GET&apos;,        header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,        Token: wx.getStorageSync(&apos;openid&apos;),        Accept: &apos;application/vnd.epet.v1+json&apos;,        },        success: function (res) {        console.log(res)        var aftherlist = that.data.shareData        var meta = res.data.meta        for (var i = 0; i &lt; res.data.data.length; i++) {            aftherlist.push(res.data.data[i])        }        that.setData({            shareData: aftherlist,            meta: meta        });        if (res.statusCode == 200) {            wx.hideLoading();        } else {            wx.hideLoading();            wx.showToast({            title: &apos;加载失败&apos;,            duration: 0,            mask: true,            success: function (res) { },            })        }        },        fail: function (res) {        wx.hideLoading();        wx.showToast({            title: &apos;加载失败&apos;,            icon: &apos;err&apos;,            duration: 2000        });        }    });    } else {    console.log(that.data.meta.pagination.links.next)    wx.showToast({        title: &apos;没有更多数据了&apos;,        mask: true,    })    }},</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh-onReachBottom&quot;&gt;&lt;a href=&quot;#微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 商品列表页瀑布流方式展示</title>
    <link href="http://gengaiwei.com/2018/03/05/wxWaterfall/"/>
    <id>http://gengaiwei.com/2018/03/05/wxWaterfall/</id>
    <published>2018-03-05T07:02:50.000Z</published>
    <updated>2020-07-20T02:45:25.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义"><a href="#根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义" class="headerlink" title="根据业务需求，商品列表页 瀑布流方式展示，展示内容自定义"></a>根据业务需求，商品列表页 瀑布流方式展示，展示内容自定义</h3><blockquote><p>1.wxml 商品列表页 瀑布流方式展示</p></blockquote><pre><code>&lt;scroll-view  scroll-y=&quot;true&quot;  class=&apos;infoall-k&apos; style=&apos;height:{{winHeight}}px&apos;&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;view class=&quot;left&quot;&gt;            &lt;block wx:for=&quot;{{yourData}}&quot; wx:key=&quot;&quot;&gt;            &lt;template is=&quot;item&quot; data=&quot;{{...item}}&quot; wx:if=&quot;{{index%2==0}}&quot;&gt;&lt;/template&gt;            &lt;/block&gt;        &lt;/view&gt;        &lt;view class=&quot;right&quot;&gt;            &lt;block wx:for=&quot;{{yourData}}&quot; wx:key=&quot;&quot;&gt;            &lt;template is=&quot;item&quot; data=&quot;{{...item}}&quot; wx:if=&quot;{{index%2==1}}&quot;&gt;&lt;/template&gt;            &lt;/block&gt;        &lt;/view&gt;    &lt;/view&gt;    &lt;template name=&quot;item&quot;&gt;        &lt;navigator url=&apos;根据你的需求，可以跳转你要的详情页的URL&apos;&gt;            &lt;view class=&quot;item&quot;&gt;            &lt;image class=&quot;item-img&quot; src=&quot;{{yourData.data}}&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;            &lt;view class=&quot;item-title-box&quot;&gt;                &lt;view class=&quot;item-title&quot;&gt;{{yourData.data}}&lt;/view&gt;                &lt;view class=&apos;item-price&apos;&gt;¥ {{yourData.data}}&lt;/view&gt;             &lt;/view&gt;            &lt;view class=&quot;item-time&quot;&gt;                &lt;text class=&quot;name-title&quot;&gt;更新于：{{yourData.data}}&lt;/text&gt;            &lt;/view&gt;            &lt;/view&gt;        &lt;/navigator&gt;    &lt;/template&gt;&lt;/scroll-view&gt;</code></pre><blockquote><p>2.css 自定义样式</p></blockquote><pre><code>.content{margin: 0 20rpx;text-align: justify; }  .item{padding: 2% 5%;border-radius: 5px;box-shadow: 3px 3px 3px #ccc;background-color: #fff;margin-bottom: 20rpx;display: inline-block;}.item-ava{width: 40rpx;height: 40rpx;border-radius: 20rpx;}.heart{width: 30rpx;height: 26rpx;margin-right: 8rpx;}.heart_{display: flex;align-items: center;}.item-img{width: 100%}.item-title,.item-price{display: inline-block;font-size: 0.8rem;width: 60%;text-overflow: ellipsis;white-space: nowrap;-webkit-box-orient: vertical;-webkit-line-clamp: 1;overflow: hidden;font-family: &apos;PingFang SC-Medium&apos;;color: #1e1e1e;margin: 15rpx 0px;}.item-price{display: inline-block;width: 40%;color: #D94038;font-size: 0.8rem;text-align: center;}.item .item-time{display: flex;align-items: center;font-size: 22rpx;color: #1e1e1e;font-family: &apos;PingFang SC-Medium&apos;;}.name image{flex: 0 0 30rpx;}.item-title-box{width: 100%;text-align: left; font-size: 1rem;color: #1e1e1e;}.name-title{flex: 1;color: #888;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 1;overflow: hidden;}.left,.right{display: inline-block;vertical-align: top;width: 49%;text-align: center;}.right{float: right;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义&quot;&gt;&lt;a href=&quot;#根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义&quot; class=&quot;headerlink&quot; title=&quot;根据业务需求，商品列表页 瀑布流方式展示，展示内容自定义&quot;&gt;&lt;/a&gt;根据
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 登录 检验登陆态 获取用户信息</title>
    <link href="http://gengaiwei.com/2018/03/05/wx-login/"/>
    <id>http://gengaiwei.com/2018/03/05/wx-login/</id>
    <published>2018-03-05T02:41:29.000Z</published>
    <updated>2020-07-20T02:45:35.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序登录-验证登录-获取用户信息"><a href="#微信小程序登录-验证登录-获取用户信息" class="headerlink" title="微信小程序登录/验证登录/获取用户信息"></a>微信小程序登录/验证登录/获取用户信息</h3><p>在app.js中，微信小程序登录之后，为确保用户间隔性打开小程序都在登录状态下，所以在这里把wx.login封装到一个函数里，在onLaunch中使用检验登录状态的wx.checkSession，如果session_key失效，再执行登录函数就可。整体的app.js总结在文章最下方。</p><blockquote><p>1.登录函数，发送code，换取openid，存在它，因后续的页面中的请求接口，需要传给接口</p></blockquote><pre><code>fun: function () {const urls = &apos;URL，也可以不在这赋给变量&apos;;// 登录wx.login({success: res =&gt; {    // 发送 res.code 到后台换取 openId, sessionKey, unionId    if (res.code) {    //发起网络请求    wx.request({        url: urls + &apos;login&apos;,        data: {        code: res.code        },        success: function (res) {        wx.setStorageSync(&apos;openid&apos;, res.data.token);        }    })    } else {    }}})</code></pre><p>},</p><blockquote><p>2.在onLaunch函数中 ，通过openid判断用户当前有没有登录，没有就调用登录方法</p></blockquote><pre><code>onLaunch: function () {var that = this;if (wx.getStorageSync(&apos;openid&apos;)) {    wx.checkSession({        success: function () {        //session_key 未过期，并且在本生命周期一直有效        },        fail: function () {        // session_key 已经失效，需要重新执行登录流程        this.fun() //重新登录        }    })} else {this.fun();}</code></pre><p>},</p><blockquote><p>3.在onLaunch函数中 ，wx.getSetting 回调中验证是否授权，如果授权过，将执行 wx.getUserInfo，获取用户信息，授权目前已更新到 需要button 触发，不支持弹出弹窗，按钮绑定 open-type=”getUserInfo” ，让用户自己选择，而不是一打开小程序 就弹出是否允许授权的窗口</p></blockquote><pre><code>wx.getSetting({    success: res =&gt; {        var that = this;        if (res.authSetting[&apos;scope.userInfo&apos;]) {        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框        wx.getUserInfo({            success: res =&gt; {            // 可以将 res 发送给后台解码出 unionId            this.globalData.userInfo = res.userInfo            wx.setStorageSync(&quot;nickName&quot;, res.userInfo.nickName)            wx.setStorageSync(&quot;avatarUrl&quot;, res.userInfo.avatarUrl)            if (res.userInfo) {                wx.request({                url: &apos;你的接口 用来发送到后台 验证授权&apos;,                method: &apos;PUT&apos;,                data: {                    nickName: wx.getStorageSync(&quot;nickName&quot;),                    avatarUrl: wx.getStorageSync(&quot;avatarUrl&quot;),                },                header: {                    &apos;content-type&apos;: &apos;application/json&apos;,                    Token: wx.getStorageSync(&apos;openid&apos;),                    Accept: &apos;application/vnd.epet.v1+json&apos;,                },                success: function (res) {},                fail: function (res) { }                });            }            // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回            // 所以此处加入 callback 以防止这种情况            if (this.userInfoReadyCallback) {                this.userInfoReadyCallback(res)            }            }        })        }    }})</code></pre><blockquote><p>4.app.js</p></blockquote><pre><code>App({    data:{    },    onLaunch: function () {        var that = this;        if (wx.getStorageSync(&apos;openid&apos;)) {        wx.checkSession({            success: function () {            //session_key 未过期，并且在本生命周期一直有效            },            fail: function () {            // session_key 已经失效，需要重新执行登录流程            this.fun() //重新登录            }        })        } else {        this.fun();        }        // 获取用户信息        wx.getSetting({        success: res =&gt; {            var that = this;            if (res.authSetting[&apos;scope.userInfo&apos;]) {            // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框            wx.getUserInfo({                success: res =&gt; {                // 可以将 res 发送给后台解码出 unionId                this.globalData.userInfo = res.userInfo                wx.setStorageSync(&quot;nickName&quot;, res.userInfo.nickName)                wx.setStorageSync(&quot;avatarUrl&quot;, res.userInfo.avatarUrl)                if (res.userInfo) {                    wx.request({                    url: &apos;http://url&apos;,                    method: &apos;PUT&apos;,                    data: {                        nickName: wx.getStorageSync(&quot;nickName&quot;),                        avatarUrl: wx.getStorageSync(&quot;avatarUrl&quot;),                    },                    header: {                        &apos;content-type&apos;: &apos;application/json&apos;,                        Token: wx.getStorageSync(&apos;openid&apos;),                        Accept: &apos;application/vnd.epet.v1+json&apos;,                    },                    success: function (res) {                    },                    fail: function (res) { }                    });                }                // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回                // 所以此处加入 callback 以防止这种情况                if (this.userInfoReadyCallback) {                    this.userInfoReadyCallback(res)                }                }            })            }        }        })    },    fun: function () {        const urls = &apos;http://url&apos;;        // 登录        wx.login({        success: res =&gt; {            // 发送 res.code 到后台换取 openId, sessionKey, unionId            if (res.code) {            //发起网络请求            wx.request({                url: urls + &apos;login&apos;,                data: {                code: res.code                },                success: function (res) {                wx.setStorageSync(&apos;openid&apos;, res.data.token);                }            })            } else {            }        }        })    },    globalData: {        userInfo: null,        urls:&apos;http://your-url/&apos; //微信小程序全局定义URL    }    })</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序登录-验证登录-获取用户信息&quot;&gt;&lt;a href=&quot;#微信小程序登录-验证登录-获取用户信息&quot; class=&quot;headerlink&quot; title=&quot;微信小程序登录/验证登录/获取用户信息&quot;&gt;&lt;/a&gt;微信小程序登录/验证登录/获取用户信息&lt;/h3&gt;&lt;p&gt;在a
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="WX" scheme="http://gengaiwei.com/tags/WX/"/>
    
  </entry>
  
</feed>
