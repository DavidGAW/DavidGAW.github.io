<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gengaiwei.com/"/>
  <updated>2018-08-16T08:34:52.083Z</updated>
  <id>http://gengaiwei.com/</id>
  
  <author>
    <name>Knight--GG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hi Man</title>
    <link href="http://gengaiwei.com/2018/08/16/hello-world/"/>
    <id>http://gengaiwei.com/2018/08/16/hello-world/</id>
    <published>2018-08-16T08:34:52.083Z</published>
    <updated>2018-08-16T08:34:52.083Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img src="/h.png" alt="Alt text"></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://gengaiwei.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>wx -- Swiper/轮播图/跑马灯</title>
    <link href="http://gengaiwei.com/2018/03/04/wxSwiper/"/>
    <id>http://gengaiwei.com/2018/03/04/wxSwiper/</id>
    <published>2018-03-04T01:13:20.000Z</published>
    <updated>2018-09-03T12:25:32.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动"><a href="#Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动" class="headerlink" title="Swiper 轮播图 也可做成跑马灯 就像信息提示/公告 在这里都是左右滚动"></a>Swiper 轮播图 也可做成跑马灯 就像信息提示/公告 在这里都是左右滚动</h3><blockquote><p>1.swiper 轮播图 wxml</p></blockquote><pre><code>&lt;view class=&apos;lunBo&apos;&gt;    &lt;swiper class=&apos;swiper&apos; indicator-dots=&apos;true&apos; autoplay=&apos;true&apos; interval=&apos;3000&apos; duration=&apos; 200&apos; circular=&apos;true&apos;&gt;        &lt;block wx:for=&quot;{{lunBoimgUrls}}&quot; wx:key=&quot;&quot;&gt;            &lt;swiper-item&gt;                &lt;image src=&quot;{{item}}&quot; class=&quot;lunBo-image&quot; /&gt;            &lt;/swiper-item&gt;        &lt;/block&gt;    &lt;/swiper&gt;&lt;/view&gt;</code></pre><blockquote><p>2.swiper 跑马灯 wxml</p></blockquote><pre><code>&lt;!--跑马灯  --&gt;&lt;view class=&apos;share-tips&apos;&gt;    &lt;view class=&apos;my-center&apos;&gt;        &lt;text class=&apos;tips-f&apos;&gt;公告：&lt;/text&gt;         &lt;swiper class=&apos;tips-k&apos;  autoplay  interval=&apos;5000&apos; duration=&apos;3000&apos; circular=&apos;true&apos; &gt;            &lt;swiper-item wx:key=&quot;&quot; wx:for=&apos;{{tipsText}}&apos;&gt;                &lt;view&gt;{{item}}&lt;/view&gt;            &lt;/swiper-item&gt;        &lt;/swiper&gt;    &lt;/view&gt;&lt;/view&gt;</code></pre><blockquote><p>3.swiper 轮播图/跑马灯 wxss</p></blockquote><pre><code>.lunBo-k{  height: 0px;}.lunBo{position: absolute;top:-54px;left: 0px;width: 100%;height: 158px;border-radius: 8px;}.lunBo swiper {height: 100%;}.lunBo swiper swiper-item{width: 100%;border-radius: 8px; }.lunBo-image{width: 100%;height: 158px; border-radius: 8px; }.tips-f{width: 20%;font-size: 0.6rem;height: 24px;line-height: 24px;float: left;}.tips-k{width: 80%;height: 24px;overflow: hidden;font-size: 12px;display: inline-block;}</code></pre><blockquote><p>4.swiper 轮播图/跑马灯 js</p></blockquote><pre><code>data: {    lunBoimgUrls: [    &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&apos;,    &apos;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&apos;,    &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg&apos;,    ],    tipsText: [    &apos;我是第一条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    &apos;我是第二条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    &apos;我是第三条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    ],},</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动&quot;&gt;&lt;a href=&quot;#Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动&quot; class=&quot;headerlink&quot; title=&quot;Swiper 轮播图 也可做成跑
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 -- 瀑布流</title>
    <link href="http://gengaiwei.com/2018/03/03/wxWaterfall/"/>
    <id>http://gengaiwei.com/2018/03/03/wxWaterfall/</id>
    <published>2018-03-03T03:00:02.000Z</published>
    <updated>2018-09-03T12:25:36.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义"><a href="#根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义" class="headerlink" title="根据业务需求，商品列表页 瀑布流方式展示，展示内容自定义"></a>根据业务需求，商品列表页 瀑布流方式展示，展示内容自定义</h3><blockquote><ol><li>wxml 商品列表页 瀑布流方式展示</li></ol></blockquote><pre><code>&lt;scroll-view  scroll-y=&quot;true&quot;  class=&apos;infoall-k&apos; style=&apos;height:{{winHeight}}px&apos;&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;view class=&quot;left&quot;&gt;            &lt;block wx:for=&quot;{{yourData}}&quot; wx:key=&quot;&quot;&gt;            &lt;template is=&quot;item&quot; data=&quot;{{...item}}&quot; wx:if=&quot;{{index%2==0}}&quot;&gt;&lt;/template&gt;            &lt;/block&gt;        &lt;/view&gt;        &lt;view class=&quot;right&quot;&gt;            &lt;block wx:for=&quot;{{yourData}}&quot; wx:key=&quot;&quot;&gt;            &lt;template is=&quot;item&quot; data=&quot;{{...item}}&quot; wx:if=&quot;{{index%2==1}}&quot;&gt;&lt;/template&gt;            &lt;/block&gt;        &lt;/view&gt;    &lt;/view&gt;    &lt;template name=&quot;item&quot;&gt;        &lt;navigator url=&apos;根据你的需求，可以跳转你要的详情页的URL&apos;&gt;            &lt;view class=&quot;item&quot;&gt;            &lt;image class=&quot;item-img&quot; src=&quot;{{yourData.data}}&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;            &lt;view class=&quot;item-title-box&quot;&gt;                &lt;view class=&quot;item-title&quot;&gt;{{yourData.data}}&lt;/view&gt;                &lt;view class=&apos;item-price&apos;&gt;¥ {{yourData.data}}&lt;/view&gt;             &lt;/view&gt;            &lt;view class=&quot;item-time&quot;&gt;                &lt;text class=&quot;name-title&quot;&gt;更新于：{{yourData.data}}&lt;/text&gt;            &lt;/view&gt;            &lt;/view&gt;        &lt;/navigator&gt;    &lt;/template&gt;&lt;/scroll-view&gt;</code></pre><blockquote><ol start="2"><li>css 自定义样式</li></ol></blockquote><pre><code>.content{margin: 0 20rpx;text-align: justify; }  .item{padding: 2% 5%;border-radius: 5px;box-shadow: 3px 3px 3px #ccc;background-color: #fff;margin-bottom: 20rpx;display: inline-block;}.item-ava{width: 40rpx;height: 40rpx;border-radius: 20rpx;}.heart{width: 30rpx;height: 26rpx;margin-right: 8rpx;}.heart_{display: flex;align-items: center;}.item-img{width: 100%}.item-title,.item-price{display: inline-block;font-size: 0.8rem;width: 60%;text-overflow: ellipsis;white-space: nowrap;-webkit-box-orient: vertical;-webkit-line-clamp: 1;overflow: hidden;font-family: &apos;PingFang SC-Medium&apos;;color: #1e1e1e;margin: 15rpx 0px;}.item-price{display: inline-block;width: 40%;color: #D94038;font-size: 0.8rem;text-align: center;}.item .item-time{display: flex;align-items: center;font-size: 22rpx;color: #1e1e1e;font-family: &apos;PingFang SC-Medium&apos;;}.name image{flex: 0 0 30rpx;}.item-title-box{width: 100%;text-align: left; font-size: 1rem;color: #1e1e1e;}.name-title{flex: 1;color: #888;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 1;overflow: hidden;}.left,.right{display: inline-block;vertical-align: top;width: 49%;text-align: center;}.right{float: right;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义&quot;&gt;&lt;a href=&quot;#根据业务需求，商品列表页-瀑布流方式展示，展示内容自定义&quot; class=&quot;headerlink&quot; title=&quot;根据业务需求，商品列表页 瀑布流方式展示，展示内容自定义&quot;&gt;&lt;/a&gt;根据
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>wx-login-checkSession-getSetting(userInfo)</title>
    <link href="http://gengaiwei.com/2018/03/02/wxLogin/"/>
    <id>http://gengaiwei.com/2018/03/02/wxLogin/</id>
    <published>2018-03-01T23:22:39.000Z</published>
    <updated>2018-09-03T12:25:25.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序登录-验证登录-获取用户信息"><a href="#微信小程序登录-验证登录-获取用户信息" class="headerlink" title="微信小程序登录/验证登录/获取用户信息"></a>微信小程序登录/验证登录/获取用户信息</h3><pre><code>在app.js中，微信小程序登录之后，为确保用户间隔性打开小程序都在登录状态下，所以在这里我把wx.login封装到一个函数里，在onLaunch中使用检验登录状态的wx.checkSession，如果session_key失效，再执行登录函数就可。在第三条写的是包含上述总结的app.js。</code></pre><blockquote><ol><li>登录函数，发送code，换取openid，存在它，因后续的页面中的请求接口，需要传给接口；</li></ol></blockquote><pre><code>  fun: function () {    const urls = &apos;URL，也可以不在这赋给变量&apos;;    // 登录    wx.login({    success: res =&gt; {        // 发送 res.code 到后台换取 openId, sessionKey, unionId        if (res.code) {        //发起网络请求        wx.request({            url: urls + &apos;login&apos;,            data: {            code: res.code            },            success: function (res) {            wx.setStorageSync(&apos;openid&apos;, res.data.token);            }        })        } else {        }    }    })},</code></pre><blockquote><ol start="2"><li>在onLaunch函数中 ，通过openid判断用户当前有没有登录，没有就调用登录方法，</li></ol></blockquote><pre><code>onLaunch: function () {    var that = this;    if (wx.getStorageSync(&apos;openid&apos;)) {        wx.checkSession({            success: function () {            //session_key 未过期，并且在本生命周期一直有效            },            fail: function () {            // session_key 已经失效，需要重新执行登录流程            this.fun() //重新登录            }        })    } else {    this.fun();    }},</code></pre><blockquote><ol start="3"><li>在onLaunch函数中 ，wx.getSetting 回调中验证是否授权，如果授权过，将执行 wx.getUserInfo，获取用户信息，授权目前已更新到 需要button 触发，不支持弹出弹窗，按钮绑定 open-type=”getUserInfo” ，让用户自己选择，而不是一打开小程序 就弹出是否允许授权的窗口</li></ol></blockquote><pre><code>wx.getSetting({  success: res =&gt; {    var that = this;    if (res.authSetting[&apos;scope.userInfo&apos;]) {      // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框      wx.getUserInfo({        success: res =&gt; {          // 可以将 res 发送给后台解码出 unionId          this.globalData.userInfo = res.userInfo          wx.setStorageSync(&quot;nickName&quot;, res.userInfo.nickName)          wx.setStorageSync(&quot;avatarUrl&quot;, res.userInfo.avatarUrl)          if (res.userInfo) {            wx.request({              url: &apos;你的接口 用来发送到后台 验证授权&apos;,              method: &apos;PUT&apos;,              data: {                nickName: wx.getStorageSync(&quot;nickName&quot;),                avatarUrl: wx.getStorageSync(&quot;avatarUrl&quot;),              },              header: {                &apos;content-type&apos;: &apos;application/json&apos;,                Token: wx.getStorageSync(&apos;openid&apos;),                Accept: &apos;application/vnd.epet.v1+json&apos;,              },              success: function (res) {              },              fail: function (res) { }            });          }          // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回          // 所以此处加入 callback 以防止这种情况          if (this.userInfoReadyCallback) {            this.userInfoReadyCallback(res)          }        }      })    }  }})</code></pre><blockquote><ol start="3"><li>app.js</li></ol></blockquote><pre><code>App({    data:{    },onLaunch: function () {    var that = this;    if (wx.getStorageSync(&apos;openid&apos;)) {    wx.checkSession({        success: function () {        //session_key 未过期，并且在本生命周期一直有效        },        fail: function () {        // session_key 已经失效，需要重新执行登录流程        this.fun() //重新登录        }    })    } else {    this.fun();    }    // 获取用户信息    wx.getSetting({    success: res =&gt; {        var that = this;        if (res.authSetting[&apos;scope.userInfo&apos;]) {        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框        wx.getUserInfo({            success: res =&gt; {            // 可以将 res 发送给后台解码出 unionId            this.globalData.userInfo = res.userInfo            wx.setStorageSync(&quot;nickName&quot;, res.userInfo.nickName)            wx.setStorageSync(&quot;avatarUrl&quot;, res.userInfo.avatarUrl)            if (res.userInfo) {                wx.request({                url: &apos;http://url&apos;,                method: &apos;PUT&apos;,                data: {                    nickName: wx.getStorageSync(&quot;nickName&quot;),                    avatarUrl: wx.getStorageSync(&quot;avatarUrl&quot;),                },                header: {                    &apos;content-type&apos;: &apos;application/json&apos;,                    Token: wx.getStorageSync(&apos;openid&apos;),                    Accept: &apos;application/vnd.epet.v1+json&apos;,                },                success: function (res) {                },                fail: function (res) { }                });            }            // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回            // 所以此处加入 callback 以防止这种情况            if (this.userInfoReadyCallback) {                this.userInfoReadyCallback(res)            }            }        })        }    }    })},fun: function () {    const urls = &apos;http://url&apos;;    // 登录    wx.login({    success: res =&gt; {        // 发送 res.code 到后台换取 openId, sessionKey, unionId        if (res.code) {        //发起网络请求        wx.request({            url: urls + &apos;login&apos;,            data: {            code: res.code            },            success: function (res) {            wx.setStorageSync(&apos;openid&apos;, res.data.token);            }        })        } else {        }    }    })},globalData: {    userInfo: null,    urls:&apos;http://your-url/&apos; //微信小程序全局定义URL}})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序登录-验证登录-获取用户信息&quot;&gt;&lt;a href=&quot;#微信小程序登录-验证登录-获取用户信息&quot; class=&quot;headerlink&quot; title=&quot;微信小程序登录/验证登录/获取用户信息&quot;&gt;&lt;/a&gt;微信小程序登录/验证登录/获取用户信息&lt;/h3&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>wxChoose-img-video</title>
    <link href="http://gengaiwei.com/2018/03/01/wxChoose/"/>
    <id>http://gengaiwei.com/2018/03/01/wxChoose/</id>
    <published>2018-03-01T02:41:29.000Z</published>
    <updated>2018-09-03T12:25:18.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序上传图片-视频，需要将图片先上传到服务器，这里是GitHub"><a href="#微信小程序上传图片-视频，需要将图片先上传到服务器，这里是GitHub" class="headerlink" title="微信小程序上传图片/视频，需要将图片先上传到服务器，这里是GitHub"></a>微信小程序上传图片/视频，需要将图片先上传到服务器，这里是<a href="https://github.com/DavidGAW/wechat-chooseImage-uploadFile" target="_blank" rel="noopener">GitHub</a></h3><pre><code>这里的上传/删除图片和视频，及上传数量的控制，详细说明在代码的注释里</code></pre><blockquote><p>1、 wxml</p></blockquote><pre><code>&lt;view class=&apos;up_image&apos;&gt;    &lt;view bindtap=&quot;upload&quot;&gt;上传图片&lt;/view&gt;    &lt;view class=&apos;image-item&apos;  wx:for=&quot;{{tempFilePaths}}&quot; wx:key=&quot;{{index}}&quot; &gt;        &lt;image class=&apos;image&apos; src=&apos;{{item}}&apos; data-index=&quot;{{index}}&quot;&gt;&lt;/image&gt;        &lt;!-- 删除按钮 --&gt;        &lt;view class=&apos;dele_item&apos; bindtap=&apos;dele_image&apos;&gt;X&lt;/view&gt;    &lt;/view&gt;    &lt;/view&gt;    &lt;view class=&apos;up_video&apos;&gt;    &lt;view bindtap=&apos;addVideo&apos;&gt;上传视频&lt;/view&gt;    &lt;view class=&apos;video-item&apos; wx:for=&quot;{{videoPaths}}&quot; wx:key=&quot;{{index}}&quot; &gt;        &lt;video src=&apos;{{item}}&apos; data-index=&quot;{{index}}&quot;&gt;&lt;/video&gt;        &lt;!-- 删除视频的按钮 --&gt;        &lt;view class=&apos;dele_item&apos; bindtap=&apos;dele_video&apos;&gt;X&lt;/view&gt;    &lt;/view&gt;&lt;/view&gt;</code></pre><blockquote><p>2、wxss</p></blockquote><pre><code>.up_image,.up_video{    text-align: center;    font-size: 0.8rem;    width: 100%;    margin: 10% auto;}.image{    width: 5rem;    height: 5rem;    display: inline-block;    margin: 0.8rem;}.video-item,.image-item{    position: relative;}.dele_item{    width: 2rem;    height: 2rem;    text-align: center;    line-height: 2rem;    color: #fff;    background:red;    position: absolute;    top: 0px;    right: 0px;}</code></pre><blockquote><p>3、js</p></blockquote><pre><code>Page({    data: {        imageVideoNumber:&apos;&apos;,        imagePicid:&apos;&apos;,        tempFilePaths:[],        videoPaths:[],        videoid:&apos;&apos;,    },// 上传图片方法=========upload: function () {    let that = this;    if ((that.data.imageVideoNumber) &lt; 9) {    wx.chooseImage({        count: 9 - (that.data.imageVideoNumber), // 默认9 imageVideoNumber 记录图片和视频已经上传的数量        sizeType: [&apos;original&apos;, &apos;compressed&apos;], // 可以指定是原图还是压缩图，默认二者都有        sourceType: [&apos;album&apos;, &apos;camera&apos;], // 可以指定来源是相册还是相机，默认二者都有        success: res =&gt; {        wx.showLoading({            title: &apos;上传中...&apos;,        })        let tempFilePaths = res.tempFilePaths;        let newtempFilePaths = res.tempFilePaths; //用于上传服务器的时候 循环新的图片数组        let arr = that.data.tempFilePaths;        tempFilePaths = tempFilePaths.concat(arr) //拼接数组的方法        that.setData({            imageVideoNumber: tempFilePaths.length + that.data.videoPaths.length,            tempFilePaths: tempFilePaths //用于页面中显示的图片路径        })        /*** 上传完成后把文件上传到服务器 */        var count = 0;        for (var i = 0; i &lt; newtempFilePaths.length; i++) {            wx.uploadFile({            url: 你需要上传到服务器的urls,            filePath: tempFilePaths[i],            name: &apos;uploadfile_ant&apos;,            header: {                &quot;Content-Type&quot;: &quot;multipart/form-data&quot;,                &quot;Accept&quot;: &quot;application/vnd.epet.v1+json&quot;,            },            success: function (res) {                count++;                if (res.statusCode == 200) {                wx.hideLoading()                wx.showModal({                    title: &apos;提示&apos;,                    content: &apos;上传成功&apos;,                    showCancel: false,                    success: function (res) {                    }                })                var imagePicid = res.data;                that.data.imagePicid.push(imagePicid)                that.setData({                    imagePicid: that.data.imagePicid //这个以什么方式传给后台，与后台商议，这里传的是ID                })                } else {                wx.hideLoading();                wx.showModal({                    title: &apos;错误提示&apos;,                    content: &apos;上传图片失败&apos;,                    showCancel: false,                    success: function (res) {                    }                })                }                //如果是最后一张,则隐藏等待中                  if (count == tempFilePaths.length) {                wx.hideToast();                }            },            fail: function (res) {                wx.hideToast();                wx.hideLoading();                wx.showModal({                title: &apos;错误提示&apos;,                content: &apos;上传图片失败&apos;,                showCancel: false,                success: function (res) {                }                })            }            });        }        }    })    } else {    wx.showModal({        title: &apos;提示&apos;,        content: &apos;上传数量已达上限&apos;,        showCancel: false,        success: function (res) {        }    })    }},// 删除图片的方法dele_image: function (e) {    var that = this;    var tempFilePaths = that.data.tempFilePaths;    var imagePicid = that.data.imagePicid; //这里的ID是后台返回你的，用于记录给后台传的ID值，如果没有上传成功后台是不会返回的，那删除就不会有作用，视频同理    var index = e.currentTarget.dataset.index;//获取当前长按图片下标    wx.showModal({    title: &apos;提示&apos;,    content: &apos;确定要删除此图片吗？&apos;,    success: function (res) {        if (res.confirm) {        console.log(&apos;点击确定了&apos;);        tempFilePaths.splice(index, 1);         imagePicid.splice(index, 1);        } else if (res.cancel) {        console.log(&apos;点击取消了&apos;);        return false;        }        that.setData({        tempFilePaths: tempFilePaths,        imageVideoNumber: that.data.imageVideoNumber - 1,        imagePicid: imagePicid        });        // console.log(that.data.tempFilePaths)        // console.log(that.data.imageVideoNumber)        // console.log(that.data.imagePicid)    }    })},// 上传视频方法==== 同理上传图片=====addVideo: function () {    var that = this    if ((that.data.imageVideoNumber) &lt; 9) {    wx.chooseVideo({        sourceType: [&apos;album&apos;, &apos;camera&apos;],        maxDuration: 60,        camera: [&apos;front&apos;, &apos;back&apos;],        success: function (res) {        wx.showLoading({            title: &apos;上传中...&apos;,        })        let videoPaths = res.tempFilePath;        that.data.videoPaths.push(videoPaths)        that.setData({            imageVideoNumber: that.data.imageVideoNumber + 1,            videoPaths: that.data.videoPaths,        })        var count = 0;        wx.uploadFile({            url: &apos;你需要上传到服务器的urls&apos;,            filePath: videoPaths,            name: &apos;uploadfile_ant&apos;,            header: {            &quot;Content-Type&quot;: &quot;multipart/form-data&quot;,            &quot;Accept&quot;: &quot;application/vnd.epet.v1+json&quot;,            },            success: function (res) {            count++;            if (res.statusCode == 200) {                wx.hideLoading()                wx.showModal({                title: &apos;提示&apos;,                content: &apos;上传成功&apos;,                showCancel: false,                success: function (res) {                }                })                var videoid = res.data;                that.data.videoid.push(videoid)                that.setData({                videoid: that.data.videoid                })            } else {                wx.hideLoading();                wx.showModal({                title: &apos;错误提示&apos;,                content: &apos;上传视频失败&apos;,                showCancel: false,                success: function (res) {                }                })            }            //如果是最后一张,则隐藏等待中              if (count == videoPaths.length) {                wx.hideToast();            }            },            fail: function (res) {            wx.hideToast();            wx.hideLoading();            wx.showModal({                title: &apos;错误提示&apos;,                content: &apos;上传视频失败&apos;,                showCancel: false,                success: function (res) {                }            })            }        });        }    });    } else {    wx.showModal({        title: &apos;提示&apos;,        content: &apos;上传数量已达上限&apos;,        showCancel: false,        success: function (res) {        }    })    }},// 删除视频的方法dele_video: function (e) {    var that = this;    var videoPaths = that.data.videoPaths;    var videoid = that.data.videoid;    var index = e.currentTarget.dataset.index;//获取当前长按图片下标    wx.showModal({    title: &apos;提示&apos;,    content: &apos;确定要删除此视频吗？&apos;,    success: function (res) {        if (res.confirm) {        console.log(&apos;点击确定了&apos;);        videoPaths.splice(index, 1);        videoid.splice(index, 1);        } else if (res.cancel) {        console.log(&apos;点击取消了&apos;);        return false;        }        that.setData({        videoPaths: videoPaths,        imageVideoNumber: that.data.imageVideoNumber - 1,        videoid: videoid        });        // console.log(that.data.videoPaths)        // console.log(that.data.imageVideoNumber)        // console.log(that.data.imagePicid)    }    })    },})</code></pre><blockquote><p>4、 如果对你有用，谢谢 Star一下<a href="https://github.com/DavidGAW/wechat-chooseImage-uploadFile" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序上传图片-视频，需要将图片先上传到服务器，这里是GitHub&quot;&gt;&lt;a href=&quot;#微信小程序上传图片-视频，需要将图片先上传到服务器，这里是GitHub&quot; class=&quot;headerlink&quot; title=&quot;微信小程序上传图片/视频，需要将图片先上传到
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Node.js -- debugging</title>
    <link href="http://gengaiwei.com/2018/02/08/node-debugging/"/>
    <id>http://gengaiwei.com/2018/02/08/node-debugging/</id>
    <published>2018-02-08T04:43:35.000Z</published>
    <updated>2018-09-03T02:29:37.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、一个只会写code的coder不是好coder"><a href="#一、一个只会写code的coder不是好coder" class="headerlink" title="一、一个只会写code的coder不是好coder"></a>一、一个只会写code的coder不是好coder</h3><blockquote><p>1、最方便也是最简单的console.log()</p></blockquote><blockquote><p>2、Node <a href="http://nodejs.cn/api/debugger.html" target="_blank" rel="noopener">原生调试 </a></p></blockquote><blockquote><p>3、第三方提供的调试工具</p></blockquote><pre><code>npm install node-inspector -g安装完之后 node-debug index.js  会在浏览器内自动打开一个窗口，就可以进行调试了npm install devtool -gnode-devtool </code></pre><blockquote><p>4、开发工具的调试</p></blockquote><pre><code>Visual Studio CodeWebStorm</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、一个只会写code的coder不是好coder&quot;&gt;&lt;a href=&quot;#一、一个只会写code的coder不是好coder&quot; class=&quot;headerlink&quot; title=&quot;一、一个只会写code的coder不是好coder&quot;&gt;&lt;/a&gt;一、一个只会写code
      
    
    </summary>
    
      <category term="Node.js" scheme="http://gengaiwei.com/categories/Node-js/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js -(global -- process) 控制台字符画</title>
    <link href="http://gengaiwei.com/2018/02/07/node-process/"/>
    <id>http://gengaiwei.com/2018/02/07/node-process/</id>
    <published>2018-02-07T02:45:31.000Z</published>
    <updated>2018-09-03T02:29:34.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简单表情符-动画"><a href="#一、简单表情符-动画" class="headerlink" title="一、简单表情符 动画"></a>一、简单表情符 动画</h3><p>   应用全局变量中的process的setout 就相当于window的console一样，输出你想输出的东西；因这里是在控制台输出动画，将下面的代码 放在一个js.文件里，<br>   然后 在控制台启动你的js文件，动画 这就要记录每一帧的变化， 然后设置一个定时器，来让它看起来在动，代码如下：</p><blockquote><p>注：控制台只能输出图形，不能输出图片，这里的表情是用的搜狗里面的表情符，但也有办法把你喜欢的图片表情包打印出来，下面会说；</p></blockquote><pre><code>var arr =[];//每个成员作为一帧；arr[arr.length]=`╭~~~╮(o^.^o)`;arr[arr.length]=`╭~~~╮(o@.@o) `;arr[arr.length]=`╭~~~╮(o~.~o)`;arr[arr.length]=`╭ ﹌╮(o&apos;.&apos;o)`;var fps =5;var current =0;var render = () =&gt; {    //将当前控制台清空（2种方法吧）    //1、这种方法还是有点不太友好；    // var height =process.stdout.getWindowSize()[1];    // for(var i=0; i&lt;height;i++){    //     process.stdout.write(&apos;\r\n&apos;);    // }    // 2、这种不错  也不知道为啥    process.stdout.write(&apos;\033[2J&apos;);    process.stdout.write(&apos;\033[0f&apos;);    //输出新内容    if(current === arr.length){        current=0;    }    process.stdout.write( arr[current++] );};setInterval(render,1000 / fps);</code></pre><h3 id="二、图片转表情符-并在控制台输出动画"><a href="#二、图片转表情符-并在控制台输出动画" class="headerlink" title="二、图片转表情符 并在控制台输出动画"></a>二、图片转表情符 并在控制台输出动画</h3><p>上述是搜狗里面自带的表情，这里说一下 可以将<a href="http://www.degraeve.com/img2txt.php" target="_blank" rel="noopener">自己喜欢的图片转化为表情符</a>，并在控制台输出；</p><blockquote><p>注：转为表情符的图片需要是在线的，并以jpg png GIF 等结尾的；也可以自己在PS中把一个GIF的动图 保存为几张图片，再将图片放到网上，我放到了GitHub上，NA，你也可以用一下；</p></blockquote><p><img src="1.jpg" width="100px" height="100px">   <img src="2.jpg" width="100px" height="100px">   <img src="3.jpg" width="100px" height="100px">  <img src="4.jpg" width="100px" height="100px"></p><blockquote><p>注：这里就要用到 node的 <code>fs</code>模块，在js所在的文件夹下建一个文件夹用来放字符画；</p></blockquote><pre><code>var fs =require(&apos;fs&apos;);var frames =[];//每个成员作为一帧；for(var i=1;i&lt;5;i++){    frames[frames.length] =fs.readFileSync(`./frames/${i}.txt`,&apos;utf8&apos;)}var fps =5;var current =0;var render = () =&gt; {    //将当前控制台清空（2种方法吧）    //1、这种方法还是有点不太友好；    // var height =process.stdout.getWindowSize()[1];    // for(var i=0; i&lt;height;i++){    //     process.stdout.write(&apos;\r\n&apos;);    // }    // 2、这种不错  也不知道为啥    process.stdout.write(&apos;\033[2J&apos;);    process.stdout.write(&apos;\033[0f&apos;);    //输出新内容    if(current === frames.length){        current=0;    }    process.stdout.write( frames[current++] );};setInterval(render,1000 / fps);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、简单表情符-动画&quot;&gt;&lt;a href=&quot;#一、简单表情符-动画&quot; class=&quot;headerlink&quot; title=&quot;一、简单表情符 动画&quot;&gt;&lt;/a&gt;一、简单表情符 动画&lt;/h3&gt;&lt;p&gt;   应用全局变量中的process的setout 就相当于window的c
      
    
    </summary>
    
      <category term="Node.js" scheme="http://gengaiwei.com/categories/Node-js/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js -- http\fs\querystring\url</title>
    <link href="http://gengaiwei.com/2018/02/06/nodejs4/"/>
    <id>http://gengaiwei.com/2018/02/06/nodejs4/</id>
    <published>2018-02-06T07:38:32.000Z</published>
    <updated>2018-09-03T02:32:21.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-js-——模块简单使用（-http-fs-querystring-url）"><a href="#Node-js-——模块简单使用（-http-fs-querystring-url）" class="headerlink" title="Node.js ——模块简单使用（ http\fs\querystring\url）"></a>Node.js ——模块简单使用（ http\fs\querystring\url）</h3><p>   前几篇文章说了node的接受请求、读取文件、包括server本身，现在就把他们总结一下吧。。。</p><blockquote><p>1、首先要引用你需要的模块</p></blockquote><pre><code>const http =require(&apos;http&apos;);const fs =require(&apos;fs&apos;);const urlLib =require(&apos;url&apos;);const querystring =require(&apos;querystring&apos;);</code></pre><blockquote><p>2、然后要创建server 来解析你在浏览器输入的信息  </p></blockquote><pre><code>http.createServer(function (req,res) {    // get    var obj =urlLib.parse(req.url,true);    var url=obj.pathname;    const GET=obj.query;    // post    var str=&apos;&apos;;    req.on(&apos;data&apos;,function (data) {    str+=data;    });    req.on(&apos;end&apos;,function () {    const POST=querystring.parse(str);        console.log(url ,GET, POST);    });</code></pre><blockquote><p>3、读取文件要创建好 文件，这里以www命名，用来放你前端的页面什么的信息（比如index.html、index.js啥的）  </p></blockquote><pre><code>    // fs    var file_name=&apos;./www&apos;+url    fs.readFile(file_name,function (err,data) {        if (err){            res.write(&apos;404&apos;);        }else {            res.write(data);        }        res.end();    })}).listen(8080);</code></pre><blockquote><p>4、总结一下，不要忘记在使用前先启动你的node</p></blockquote><pre><code>const http =require(&apos;http&apos;);const fs =require(&apos;fs&apos;);const urlLib =require(&apos;url&apos;);const querystring =require(&apos;querystring&apos;);http.createServer(function (req,res) {    // get    var obj =urlLib.parse(req.url,true);    var url=obj.pathname;    const GET=obj.query;    // post    var str=&apos;&apos;;    req.on(&apos;data&apos;,function (data) {    str+=data;    });    req.on(&apos;end&apos;,function () {    const POST=querystring.parse(str);        console.log(url ,GET, POST);    });    // fs    var file_name=&apos;./www&apos;+url    fs.readFile(file_name,function (err,data) {        if (err){            res.write(&apos;404&apos;);        }else {            res.write(data);        }        res.end();    })}).listen(8080);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Node-js-——模块简单使用（-http-fs-querystring-url）&quot;&gt;&lt;a href=&quot;#Node-js-——模块简单使用（-http-fs-querystring-url）&quot; class=&quot;headerlink&quot; title=&quot;Node.js 
      
    
    </summary>
    
      <category term="Node.js" scheme="http://gengaiwei.com/categories/Node-js/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 之 数据请求</title>
    <link href="http://gengaiwei.com/2018/02/05/nodejs2/"/>
    <id>http://gengaiwei.com/2018/02/05/nodejs2/</id>
    <published>2018-02-05T01:27:33.000Z</published>
    <updated>2018-08-16T08:34:52.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Node-js-——-作为一个有追求的服务器"><a href="#一、Node-js-——-作为一个有追求的服务器" class="headerlink" title="一、Node.js —— 作为一个有追求的服务器"></a>一、Node.js —— 作为一个有追求的服务器</h3><p> 在[ <a href="/2018/02/02/nodejs1/" title="Node.js 之 优势及配置">Node.js 之 优势及配置</a> ]中说过，就把node当做一个服务器，一个服务器该有的职能就应要有请求数据、读取文件、创建服务呀。NA，现在该整整数据的事了吧，通常情况下，浏览器跟服务器之间甭管你是请求还是响应，其实都是信息啊，信息里面都有一个header跟content，头小身子大，header里面就放的URL啊还有一些头信息，content里面一般就放post数据主体数据了，前台请求后台的数据方式有很多种，至少有三种常用的Form、Ajax、Jsonp,但对于后台来说，对于Node来说，处理的方式都一样，都是接到的http请求，走HTTP协议的，只不过是前台请求的方式不同，常见的GET啊、POST啊，DELETE啥啥的不常用也就不扯了，主要扯一扯GET、POST。</p><h4 id="1、请求方式-——-GET（数据在URL中）"><a href="#1、请求方式-——-GET（数据在URL中）" class="headerlink" title="1、请求方式 —— GET（数据在URL中）"></a>1、请求方式 —— GET（数据在URL中）</h4><p>就以form表单为例吧，在文件夹里建个<code>form.html</code>还有<code>server.js</code>:<br>(1).form.html    action就以你写的那个端口，与server.js里面的端口号要一样，method方法这里就为get</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;form&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;http://localhost:8080/&quot; method=&quot;get&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;        用户名：&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(2).server.js   别忘记启动它   <code>node server.js</code> [ <a href="/2018/02/02/nodejs1/" title="Node.js 之 优势及配置">Node.js 之 优势及配置</a> ]里有详细说明    </p><pre><code>const http=require(&apos;http&apos;);http.createServer(function (req,res) {    console.log(req.url);    res.write(&quot;aaa&quot;);    res.end();}).listen(8080);</code></pre><p>(3).在浏览器中打开form.html 表单随便输，这里输入asd 密码123456 点击提交的时候看着后台返回的东西，如图所示:  </p><p><img src="01.png" alt=""></p><blockquote><h5 id="Just-say"><a href="#Just-say" class="headerlink" title="Just say"></a>Just say</h5></blockquote><p>   上面get请求中的URL里面返回的‘/?user=啥啥一坨’，‘？’的前面就是地址，后面的就是请求的数据，那怎么 <strong>解析数据</strong> ；<br>   先把 form 的action后面加个地址 action=”<a href="http://localhost:8080/aaa&quot;" target="_blank" rel="noopener">http://localhost:8080/aaa&quot;</a> aaa是随便写的 重复上面的步骤，就会在后台打印出<code>&#39;/aaa?user=asd&amp;pass=123456&#39;</code>。<br>       解析GET数据方法有好多，最笨的方法是自己手动把数据切割解析出来，还有node提供的两个模块：querystring、url；<br>（1）.自己切割数据 —— 虽然过程很痛苦，但值得尝试</p><pre><code>const http=require(&apos;http&apos;);http.createServer(function (req,res) {    //console.log(req.url);打印出来URL 还会贱贱的多一个/favicon.ico 所以要加个判断    var Arr ={ };//放数据    if(req.url.indexOf(&apos;?&apos;)!=-1){        var arr= req.url.split(&apos;?&apos;);        // arr[0]=&gt;地址  &apos;/aaa&apos;        // arr[1]=&gt;数据  &apos;user=asd&amp;pass=123456&apos;        var url =arr[0]        var arr2= arr[1].split(&quot;&amp;&quot;);        for(var i=0;i&lt;arr2.length;i++){            var arr3 =arr2[i].split(&apos;=&apos;);            Arr[arr3[0]]=arr3[1]        }    }else {        var url=req.url;    }    console.log(url,Arr);    res.write(&quot;aaa&quot;);    res.end();}).listen(8080);</code></pre><p>（2）.node —— querystring  </p><pre><code>const http=require(&apos;http&apos;);const querystring=require(&apos;querystring&apos;);http.createServer(function (req,res) {    var Arr ={ };    if(req.url.indexOf(&apos;?&apos;)!=-1){        var arr= req.url.split(&apos;?&apos;);        var url =arr[0]        var Arr= querystring.parse(arr[1]) ;    }else {        var url=req.url;    }    console.log(url,Arr);    res.write(&quot;aaa&quot;);    res.end();}).listen(8080);</code></pre><p>（3）.node —— url      </p><pre><code>const http=require(&apos;http&apos;);const user_url=require(&apos;url&apos;);http.createServer(function (req,res) {    var obj= user_url.parse(req.url,true);    var url=obj.pathname;    var Arr=obj.query;    console.log(url,Arr);    res.write(&quot;aaa&quot;);    res.end();}).listen(8080);</code></pre><h4 id="2、请求方式-——-POST（数据不在URL中）"><a href="#2、请求方式-——-POST（数据不在URL中）" class="headerlink" title="2、请求方式 —— POST（数据不在URL中）"></a>2、请求方式 —— POST（数据不在URL中）</h4><p>post在格式上跟get长得差不多，但post数据的接收要比get大得多，为了数据传送稳定快捷方便，就<code>分段发送，分段接收</code>，这里两个事件：<code>data</code>事件是指数据量的大小，有一次数据到达就触发一次，就有一段数据已发送过来，<code>end</code>事件只发生一次，即数据全部传送结束时触发；</p><pre><code>const http =require(&apos;http&apos;);const querystring=require(&apos;querystring&apos;);http.createServer(function (req,res) {    // post---req    var str =&apos;&apos;;//接收数据，这里暂时用字符串    var i=0;    req.on(&apos;data&apos;,function (data) {        console.log(i++ +&apos;次收到数据&apos;); //可以看出收到几次数据        str+=data;    });    req.on(&apos;end&apos;,function (data) {        var post_con=querystring.parse(str)        // console.log(post_con);    });}).listen(8080);</code></pre><p><strong><em>总结：</em></strong> 这里解析post、get数据用的是node提供的模块<code>querystring</code>、<code>url</code>，还有[ <a href="/2018/02/04/nodejs3/" title="Node.js 之 文件读取">Node.js 之 文件读取</a> ]， 到目前阶段, node接受请求、读取文件、包括server本身已整理，那么终于可以进行下一步完整的搭建了，抽时间，整一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Node-js-——-作为一个有追求的服务器&quot;&gt;&lt;a href=&quot;#一、Node-js-——-作为一个有追求的服务器&quot; class=&quot;headerlink&quot; title=&quot;一、Node.js —— 作为一个有追求的服务器&quot;&gt;&lt;/a&gt;一、Node.js —— 作
      
    
    </summary>
    
      <category term="Node.js" scheme="http://gengaiwei.com/categories/Node-js/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js -- fs.readFile/writeFile</title>
    <link href="http://gengaiwei.com/2018/02/04/nodejs3/"/>
    <id>http://gengaiwei.com/2018/02/04/nodejs3/</id>
    <published>2018-02-04T02:53:51.000Z</published>
    <updated>2018-09-03T02:32:16.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、fs-——-readFile-读文件"><a href="#一、fs-——-readFile-读文件" class="headerlink" title="一、fs —— readFile 读文件"></a>一、fs —— readFile 读文件</h3><p><strong><em><code>fs</code></em></strong> 是 node 提供的文件系统模块，这里只简单说下fs中的<code>readFile、writeFile</code>，引用require(‘fs’)。readFile包括两个参数，一个是文件名，一个回调函数（两个参数，err、data），这里把需要读的文件放到一个文件夹里，方便增删文件，这里命名<code>www</code>，里面随便写了两个html，req.url请求的时候如果请求地址没有这两个HTML，那就返回404，有的话就在页面中显示所访问的HTML</p><pre><code>const http =require(&apos;http&apos;);const fs =require(&apos;fs&apos;);const server =http.createServer(function (req ,res) {   var file_name=  &apos;./www&apos;+req.url;    fs.readFile(file_name,function (err,data) {        if(err){            res.write(&apos;404&apos;);        }else{            res.write(data);        }        res.end();    })}).listen(&apos;8080&apos;);</code></pre><p>如图：<br><img src="01.png" alt=""><br><img src="02.png" alt=""></p><h3 id="二、fs-——-writeFile-写文件"><a href="#二、fs-——-writeFile-写文件" class="headerlink" title="二、fs —— writeFile 写文件"></a>二、fs —— writeFile 写文件</h3><p> 既然是写文件，那就不用新建文件夹，writeFile包括三个参数：文件名、内容、回调函数，随便写个文件名，写些内容，当前文件夹下就会自动生成一个文件，如下：</p><pre><code>const fs=require(&apos;fs&apos;);fs.writeFile(&apos;bb.txt&apos;,&apos;123123123&apos;,function (err) {    if(err){        console.log(&apos;读取失败&apos;);    }else{    }});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、fs-——-readFile-读文件&quot;&gt;&lt;a href=&quot;#一、fs-——-readFile-读文件&quot; class=&quot;headerlink&quot; title=&quot;一、fs —— readFile 读文件&quot;&gt;&lt;/a&gt;一、fs —— readFile 读文件&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Node.js" scheme="http://gengaiwei.com/categories/Node-js/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js -- nvm</title>
    <link href="http://gengaiwei.com/2018/02/03/nvm1/"/>
    <id>http://gengaiwei.com/2018/02/03/nvm1/</id>
    <published>2018-02-03T08:37:03.000Z</published>
    <updated>2018-09-03T03:09:04.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="node-的版本控制-NVM"><a href="#node-的版本控制-NVM" class="headerlink" title="node 的版本控制 NVM"></a>node 的版本控制 NVM</h3><blockquote><p>1、安装下载 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-Windows</a><br>2、解压到全英文的路径；<br>3、编辑解压~settings.tex ~文件（不存在就新建）    </p></blockquote><pre><code>root: C:\dev\nvmpath: C:\dev\nodejsarch:64     //系统，若你是32 就写32proxy: none  //本地如果没有代理的话 不用写 直接不要这个也行</code></pre><blockquote><p>4、配置环境变量 可以通过window +r :sysdm.cpl 打开高级中的环境变量，新建下面内容；</p></blockquote><pre><code>NVM_HOME = nvm.exe所在目录NVM_SYMLINK =node 快捷键所在位置Path +=%NVM_HOME%；%NVM_SYMLINK%；</code></pre><p>如图：<br><img src="nvm_02.png" alt=""></p><blockquote><p>5、查看是否配置成功 ，打开cmd 输入set命令</p></blockquote><p>如图：<br><img src="nvm_01.png" alt=""></p><blockquote><p>6、也可以通过Windows中的 powershell查看 通过dir env: 回车查看</p></blockquote><p>如图：<br><img src="nvm_03.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;node-的版本控制-NVM&quot;&gt;&lt;a href=&quot;#node-的版本控制-NVM&quot; class=&quot;headerlink&quot; title=&quot;node 的版本控制 NVM&quot;&gt;&lt;/a&gt;node 的版本控制 NVM&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、安装下载 &lt;a
      
    
    </summary>
    
      <category term="Node.js 、NVM" scheme="http://gengaiwei.com/categories/Node-js-%E3%80%81NVM/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 之 优势及安装配置</title>
    <link href="http://gengaiwei.com/2018/02/02/nodejs1/"/>
    <id>http://gengaiwei.com/2018/02/02/nodejs1/</id>
    <published>2018-02-02T08:37:03.000Z</published>
    <updated>2018-09-03T02:29:31.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Node-——-advantages？"><a href="#一、Node-——-advantages？" class="headerlink" title="一、Node —— advantages？"></a>一、Node —— advantages？</h3><p>1、性能高，根据大佬们测试，<code>高于PHP86倍</code>，就同样的设备同样的硬件运行node与PHP，node 用1s反馈，那PHP就要用一分半钟，是不是可以这样理解，如果PHP需要100台服务器，那node要一台就够了。。。</p><p>2、与前台js配合方便， 前台的编译代码、部署等等；</p><p>3、node 模块化 自定义模块，支持<code>es6</code>，框架有<code>express、koa</code>等；</p><p>4、更便于前端学习，人生苦短，Java PHP学不会。。。So,掌握好JavaScript本身，学起来node就变得简单多了，node做后台，JavaScript做前台，perfect。</p><h3 id="二、Node-——-How-to-use-it"><a href="#二、Node-——-How-to-use-it" class="headerlink" title="二、Node —— How to use it?"></a>二、Node —— How to use it?</h3><blockquote><p>1、安装，NA，<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>  Download LTS稳定版，步骤呢， step step；</p></blockquote><blockquote><p>2、open your 终端，write node 回车 如果没啥东西的话表示安装成功了 ，如果报错了，也别急，试试重启电脑。</p></blockquote><blockquote><p>3、now ，you can play it！<br>            （1）、首先呢你要记住 node.js他就像一个服务器，现在你是后端，你是后端，你是后端！现在你不需要建HTML啊css啊，就建个js ，<br>            （2）、随便在哪个盘里 建个文件夹，但也不能瞎建，后面要用，栗如在F盘吧，你建个node命名的文件夹，然后打开编辑器，拖进来，建个<code>xxx.js</code>就叫1.js吧，里面写点儿啥啊，得让它跑起来是吧，就先在 1.js 里面写个最简单的，<code>console.log(&quot;hello world&quot;)</code>，之前写个HTML在浏览器打开就能看见打印的东西，这咋看呢，不急。 打开终端，你maybe切盘 切到你建的那个文件夹所在的盘里，切哪个，哪个盘的后面加上冒号，<br>                 这里应该是<code>F：</code>回车 切到了F盘，再得切到你建的文件夹吧 快捷键<code>cd</code>你的文件夹名字 回车  然后 <code>node空格1.js</code> 现在就看见了吧<br>            （3）、如果你也讨厌每次都要在终端运行 每次都要打开这黑乎乎的东西，就在编辑器里打开，maybe 不用你切换文件夹目录，直接node空格你的js文件名就可以，如果没错的话 就打印出来了吧，你想停掉的话 快捷键 <code>Ctrl+C</code> ；</p></blockquote><blockquote><p>4、node就是一个 <strong>服务器</strong>，一个有追求的服务器，那得有人访问啊，访问得通过浏览器访问吧，浏览器跟服务器之间连接需要HTTP协议吧，但HTTP很复杂的，上面说过了，node 模块化 有很多的模块 拿来用就可以了 ，now，引用 <code>http</code>模块吧：<br>（1）、 引用方式：</p></blockquote><pre><code>const http=require(&apos;http&apos;);</code></pre><blockquote><p>（2）引用完之后，上面说了node就是一个 <strong>服务器</strong>，所以呀得创建个服务啊， 服务器不能过节不能休息吧，一台服务器永远都在运行，所以得有监视他，这里就叫监听<code>（listen）</code>，监听就好比小区看门的大爷，你说要去张三，大爷说了：“那个啥，张三就在三号楼三单元301，”，说白了 当有人访问的时候得有个人得在那等着，告诉你该去哪去哪，你要是找的人不在这个小区，那就走吧，找不到你要的人啊。所以啊，你找的谁，谁就是个端口啊，有这个端口，那你就进来，没这个端口，那sorry，<code>localhost</code> may refuse your request；<br>   端口有好多（80开头的就代表web、还有邮件的110、数据库的3306啊等等），don’t repeat，确保唯一性，这里的监听端口就以大众版的“8080”吧，如下</p></blockquote><pre><code>var server =http.createServer(function (req,res) {     //req 请求；res响应；     console.log(req.url);//打印一下看看node给你返回啥     res.write(&quot;你请求了 我得给你响应吧&quot;);//这是一个简单的往前台写东西，毕竟总不能你访问啥URL我都给你返回这句话吧；     res.end();//告诉服务器一声，结束请求});//端口---就是数字 ；监听---就是等着，等着人来server.listen(&quot;8080&quot;);//不是想看看给你打印的啥吗？先启动你的node node xxx.js 没错的话就打开浏览器输入---》localhost：8080  ！回车的同时看着你的node！</code></pre><p>  <table><tr><td bgcolor="orange">注:你试试在localhost：8080/xxx ,node 的后台就会打印出来你xxx的东西，你还会发现 还有一个/favicon.ico 都知道 就是那个图标，就当Google多情了吧;</td></tr></table><br>  你也可以这样写：</p><pre><code>const http=require(&apos;http&apos;);http.createServer(function (req,res) {  console.log(req.url);     res.write(&quot;aaa&quot;);     res.end();}).listen(8080);</code></pre><p>   如图所示:<br>   <img src="1.png" alt=""><br><br>  </p><hr><p>OK, 已经很啰嗦的  写了关于node 的安装配置以及一丁点的基本使用，I hope it works for you，see you</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Node-——-advantages？&quot;&gt;&lt;a href=&quot;#一、Node-——-advantages？&quot; class=&quot;headerlink&quot; title=&quot;一、Node —— advantages？&quot;&gt;&lt;/a&gt;一、Node —— advantages？&lt;/
      
    
    </summary>
    
      <category term="Node.js" scheme="http://gengaiwei.com/categories/Node-js/"/>
    
    
      <category term="Node" scheme="http://gengaiwei.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="http://gengaiwei.com/2018/01/31/React/"/>
    <id>http://gengaiwei.com/2018/01/31/React/</id>
    <published>2018-01-31T01:53:44.000Z</published>
    <updated>2018-09-01T09:45:00.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>创建新应用吧，嗯gg<br>Create React App 是开始构建新的 React 单页面应用的最佳途径。 它可以帮你配置开发环境，以便你可以使用最新的 JavaScript 特性，还能提供很棒的开发体验，并为生产环境优化你的应用。</p><p>npm install -g create-react-app<br>create-react-app my-app</p><p>cd my-app<br>npm start</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;p&gt;创建新应用吧，嗯gg&lt;br&gt;Create React App 是开始
      
    
    </summary>
    
      <category term="框架" scheme="http://gengaiwei.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web前端" scheme="http://gengaiwei.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git -- command/project management</title>
    <link href="http://gengaiwei.com/2018/01/02/Git/"/>
    <id>http://gengaiwei.com/2018/01/02/Git/</id>
    <published>2018-01-02T08:47:06.000Z</published>
    <updated>2018-09-03T02:30:47.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h3><blockquote><p>1、首先，下载安装<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">git</a></p></blockquote><blockquote><p>2、下载之后打开，双击<code>.pkg</code>安装;</p></blockquote><blockquote><p>3、 打开终端，使用<code>git --version</code>命令查看安装版本，有就是安装成功了</p></blockquote><blockquote><p>4、创建一个用户名：<code>git config --global user.name &quot;NAME&quot;</code> ，这里的NAME可以随便取</p></blockquote><blockquote><p>5、创建一个邮箱：<code>git config --global user.email &quot;MY_NAME@example.com&quot;</code>，这里的邮箱应该跟 GitBlit（目前公司用这个，自己也用GitHub） 服务器上注册的邮箱一致<br>然后，使用git命令上传本地文件至git服务器:</p></blockquote><pre><code>(1)在终端进入你想要创建git的目录下，先初始化：`git init`(2)连接远程服务器：`git remote add origin ssh://xxxxx@10.2.10.208:29418/qinghua.git`(这里写版本库地址)(3)在将本地文件上传至git服务器之前，先上传一个测试文件，相当于激活一下服务器上的git库(4)新建一个文件：`touch README.md`，这里的文件名可以随意取，创建完了之后可以用`git status`查看一下(5)将文件上传到本地git库：`git add filename`(6)上传之前，给本次上传取一个名字：`git commit －m  &apos;test&apos; `，这里的名字test可以随意取(7)将本地git库的文件上传到git服务器库里：`git push －u origin master`</code></pre><h3 id="Git-上传项目命令"><a href="#Git-上传项目命令" class="headerlink" title="Git 上传项目命令"></a>Git 上传项目命令</h3><p>1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库</p><pre><code>git init</code></pre><p>2、把文件添加到版本库中，使用命令git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件</p><pre><code>git add .</code></pre><p>3、用命令git commit告诉Git，把文件提交到仓库。引号内为提交说明</p><pre><code>git commit -m &apos;first commit&apos;</code></pre><p>4、关联到远程库</p><pre><code>git remote add origin 你的远程库地址如：git remote add origin https://github.com/cade8800/ionic-demo.git</code></pre><p>5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）</p><pre><code>git pull --rebase origin master</code></pre><p>6、把本地库的内容推送到远程，使用 <code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。</p><pre><code>git push -u origin master</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Git-安装&quot;&gt;&lt;a href=&quot;#Git-安装&quot; class=&quot;headerlink&quot; title=&quot;Git 安装&quot;&gt;&lt;/a&gt;Git 安装&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、首先，下载安装&lt;a href=&quot;http://git-scm.com/down
      
    
    </summary>
    
      <category term="Git" scheme="http://gengaiwei.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://gengaiwei.com/tags/Git/"/>
    
  </entry>
  
</feed>
