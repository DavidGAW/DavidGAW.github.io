<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ellen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gengaiwei.com/"/>
  <updated>2020-07-24T05:52:48.071Z</updated>
  <id>http://gengaiwei.com/</id>
  
  <author>
    <name>Ellen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript（二）：接口与类</title>
    <link href="http://gengaiwei.com/2020/07/24/TypeScript%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB/"/>
    <id>http://gengaiwei.com/2020/07/24/TypeScript（二）：接口与类/</id>
    <published>2020-07-24T04:31:06.000Z</published>
    <updated>2020-07-24T05:52:48.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TypeScript  的核心之一 就是对值（数据）所具有的结构进行类型检查、类型的约定、除了基本类型的检查，还有就是接口，用接口来进行标注；</p><h3 id="一、接口"><a href="#一、接口" class="headerlink" title="一、接口"></a>一、接口</h3><pre><code>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现；是对复杂的对象类型进行标注的一种方式，或者给其他代码定义一种契约（比如：类）。</code></pre><h4 id="1-对【对象的形状】进行描述"><a href="#1-对【对象的形状】进行描述" class="headerlink" title="1. 对【对象的形状】进行描述"></a>1. 对【对象的形状】进行描述</h4><p>基本使用：举个🌰<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注：接口一般首字母大写</p><p>标注此接口 接口仅表示一种类型 不能作为值去使用，并且用接口的变量 需要履行契约；定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//接口中有 name、age</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这么写 会报错 缺少 age</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//这么写 会报错 gender不在类型Person中</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender:  &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><table><tr><td bgcolor="orange">所以：赋值的时候，变量的形状必须和接口的形状保持一致 </td></tr></table><blockquote><p>接口的其他属性规则:</p></blockquote><h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><p>接口中的某个属性 可以不存在，但也不能添加未定义的属性</p><p>在属性 <code>：</code>  前加 <code>？</code> ，这样此接口属性被履行时，<code>gender</code> 被视为可选属性<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:number;</span><br><span class="line">    gender?:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let who :Person =&#123;</span><br><span class="line">    name:&apos;zhangsan&apos;,</span><br><span class="line">    age:18,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h5><p>如果我们希望对象中的一些字段只能在创建的时候被复制，那么就可以用<code>readonly</code> 定义只读属性， 只能用来读取 ,不可被修改<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person1&#123;</span><br><span class="line">    readonly name:string;</span><br><span class="line">    readonly age:number;</span><br><span class="line">    tel?:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建时 赋值</span><br><span class="line">let per1 : Person1 = &#123;</span><br><span class="line">    name:&apos;lisi&apos;,</span><br><span class="line">    age:18,</span><br><span class="line">    tel:&apos;155....&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">per1.age;</span><br><span class="line">per1.age = 20;    //报错：无法分配到&quot;age&quot; ，因为它是只读属性</span><br><span class="line">per1.tel= &apos;133…’  //可以被修改</span><br></pre></td></tr></table></figure></p><h5 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h5><p>当接口中已标注属性不满足我们需要的属性时，当我们不知道除了<code>name</code>、<code>age</code>属性外还有其他什么属性的时候，并且需要扩展接口属性的时候；【占位符】<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person2&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:string;</span><br><span class="line">    [propName:string]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let per2 : Person2 = &#123;</span><br><span class="line">    name:&apos;lisi&apos;,</span><br><span class="line">    age:&apos;18&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">per2[&apos;gender&apos;] = &apos;male&apos;; //或者 per2.gender= “male&quot; ;</span><br></pre></td></tr></table></figure></p><p>注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number; // 报错：’age&apos;的 &apos;number&apos;不是’string&apos;的子属性.</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25, </span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一个接口只能定义一个任意属性，如果接口中有多个类型的属性，则可以在任意属性中使用联合类型<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number; //这样就不报错了</span><br><span class="line">    [propName: string]: string | number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &apos;Tom&apos;,</span><br><span class="line">    age: 25, </span><br><span class="line">    gender: &apos;male&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="2-对【类】的一部分行为进行抽象，用【类】实现接口"><a href="#2-对【类】的一部分行为进行抽象，用【类】实现接口" class="headerlink" title="2.  对【类】的一部分行为进行抽象，用【类】实现接口"></a>2.  对【类】的一部分行为进行抽象，用【类】实现接口</h4><p>在类中使用必须要被遵循的接口可以使用 <code>implements</code> 关键字来确保其兼容性：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Someone&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Students implements Someone &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name:string,age:number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        console.log(`$&#123;this.age&#125; 岁的 $&#123;this.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newP = new Students(“Luke&quot;, 18);</span><br></pre></td></tr></table></figure></p><p>进阶一下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Teacher extends Students implements Someone &#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    constructor(name:string,age:number)&#123;    </span><br><span class="line">        super(name,age); //表示当前继承的类Students的构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        console.log(`$&#123;this.name&#125;那年:$&#123;this.age&#125;岁`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newT = new Teacher(&apos;youda&apos;,1000)</span><br></pre></td></tr></table></figure></p><h4 id="3-接口的继承"><a href="#3-接口的继承" class="headerlink" title="3.  接口的继承"></a>3.  接口的继承</h4><p>使用 关键字 <code>extends</code> 来继承<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Someone&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Skill extends Someone&#123;</span><br><span class="line">    category1:string;</span><br><span class="line">    category2:string;</span><br><span class="line">    category3:string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以当定义变量 使用 <code>Skill</code> 时，需要遵循接口的属性，如下<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let onePer : Skill = &#123;</span><br><span class="line">    name:&apos;luke&apos;,</span><br><span class="line">    age:40,</span><br><span class="line">    category1:&apos;html&apos;,</span><br><span class="line">    category2:&apos;js&apos;,</span><br><span class="line">    category3:&apos;css&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另：接口还可以继承多个接口  使用  <code>逗号</code> 隔开；<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Who extends Skill,Someone&#123;</span><br><span class="line">    teacher:string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h3><p>我们知道类定义了一件事物的抽象特点，包含它的属性和方法，还有类的实例是通过 <code>new</code> 生成，TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><h4 id="1-ES6中类的用法"><a href="#1-ES6中类的用法" class="headerlink" title="1. ES6中类的用法"></a>1. ES6中类的用法</h4><blockquote><p>(1). 属性和方法</p></blockquote><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `我是 $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oneSt = new Student(&quot;luke_st&quot;);</span><br><span class="line">console.log(oneSt.sayHi());</span><br></pre></td></tr></table></figure></p><blockquote><p>(2). 类的继承</p></blockquote><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Dad &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        console.log(`im your dad`)</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `我是你$&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Dad &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name); // 调用父类的 constructor(name)</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `你好 $&#123;super.sayHi()&#125;`; // 调用父类的 sayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s = new Son(&apos;erzi&apos;);</span><br><span class="line">console.log(s.sayHi());</span><br></pre></td></tr></table></figure></p><blockquote><p>(3). 存取器</p></blockquote><p>使用 <code>getter</code> 和 <code>setter</code> 可以改变属性的赋值和读取:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return &apos;lisi&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value) &#123;</span><br><span class="line">        console.log(&apos;setter: &apos; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newStudent = new Student(&quot;zhangsan&quot;); // setter: zhangsan</span><br><span class="line">newStudent.name = &quot;wangwu&quot;; // setter: wangwu</span><br><span class="line">console.log(newStudent.name); // lisi</span><br></pre></td></tr></table></figure></p><h4 id="2-TypeScript中类的用法"><a href="#2-TypeScript中类的用法" class="headerlink" title="2. TypeScript中类的用法"></a>2. TypeScript中类的用法</h4><blockquote><p>(1). 修饰符</p></blockquote><p>TypeScript 可以使用三种访问修饰符，分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><p>使用 <code>public</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    public constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 = new Student(&quot;zhangsan&quot;);</span><br><span class="line">console.log(s1.name); // zhangsan</span><br><span class="line">s1.name = &apos;lisi&apos;;</span><br><span class="line">console.log(s1.name); // lisi</span><br></pre></td></tr></table></figure></p><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    public constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 = new Student(&quot;zhangsan&quot;);</span><br><span class="line">console.log(s1.name); //报错： 属性“name”为私有属性，只能在类“Student”中访问</span><br><span class="line">s1.name = &apos;lisi&apos;;</span><br></pre></td></tr></table></figure></p><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Dad &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        console.log(`im your dad`);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `我是你$&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Dad &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name); </span><br><span class="line">        console.log(this.name); //报错： 属性“name”为私有属性，只能在类“Dad”中访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Dad &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Dad &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name); //可以访问父级</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>(2). 参数属性</p></blockquote><p>修饰符和 <code>readonly</code> 还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">// public name: string;</span><br><span class="line">public constructor(public name:string) &#123;</span><br><span class="line">    // this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>(3).  readonly</p></blockquote><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    readonly name: string;</span><br><span class="line">    public constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 = new Student(&quot;zhangsan&quot;);</span><br><span class="line">console.log(s1.name); // zhangsan</span><br><span class="line">s1.name = &quot;lisi”; //报错：无法分配到 &quot;name&quot; ，因为它是只读属性</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;TypeScript  的核心之一 就是对值（数据）所具有的结构进行类型检查、类型的约定、除了基本类型的检查，还有就是接口，用接口来进行标注
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://gengaiwei.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://gengaiwei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 使用qs</title>
    <link href="http://gengaiwei.com/2020/07/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8qs/"/>
    <id>http://gengaiwei.com/2020/07/23/微信小程序-使用qs/</id>
    <published>2020-07-23T10:25:49.000Z</published>
    <updated>2020-07-27T05:17:30.893Z</updated>
    
    <content type="html"><![CDATA[<p>官方：<a href="https://www.npmjs.com/package/qs" target="_blank" rel="noopener">qs</a> 是 具有一些附加安全性的 查询字符串解析 和 字符序列化 库。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>可以npm安装 也可以直接到官方下载js文件包到本地项目 推荐使用<a href="/source/_posts/微信小程序-使用-NPM.md">npm</a>安装</p><pre><code>npm i qs</code></pre><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><ol><li>本地引入文件： <code>const qs = require(&#39;/文件夹下/qs.js&#39;);</code></li><li>npm引入：  <code>import qs from &#39;/miniprogram_npm/找到qs&#39;;</code></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>qs.stringify()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qs.stringify(&#123;userName:&apos;admin&apos;, password:&apos;123456&apos;&#125;)</span><br><span class="line">//userName=admin&amp;password=123456</span><br></pre></td></tr></table></figure><p>qs.parse()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = &quot;username=&apos;admin&apos;&amp;password=&apos;123456&apos;&quot;</span><br><span class="line">const obj = qs.parse(str)</span><br><span class="line">输出 obj //  &#123; username: &quot;admin&quot;, password: &quot;123456&quot; &#125;</span><br></pre></td></tr></table></figure><p><em>ps：无论小程序、vue 引用使用方式都相同</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方：&lt;a href=&quot;https://www.npmjs.com/package/qs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qs&lt;/a&gt; 是 具有一些附加安全性的 查询字符串解析 和 字符序列化 库。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 一些js处理</title>
    <link href="http://gengaiwei.com/2020/07/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://gengaiwei.com/2020/07/23/微信小程序-一些开发技巧/</id>
    <published>2020-07-23T08:24:33.000Z</published>
    <updated>2020-07-27T04:53:26.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-一些js处理"><a href="#微信小程序-一些js处理" class="headerlink" title="微信小程序  一些js处理"></a>微信小程序  一些js处理</h3><h4 id="input输入框输入数字时-只能输入小数点后两位"><a href="#input输入框输入数字时-只能输入小数点后两位" class="headerlink" title="input输入框输入数字时 只能输入小数点后两位"></a>input输入框输入数字时 只能输入小数点后两位</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bindInput: function(e) &#123;</span><br><span class="line">  let value = e.detail.value;</span><br><span class="line">  let index = value.indexOf(&quot;.&quot;);</span><br><span class="line">  if (index == -1) &#123;</span><br><span class="line">    if (value.length &gt; 4) &#123;</span><br><span class="line">      value = value.substring(0, 4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (value.length - 3 &gt; index) &#123;</span><br><span class="line">      value = value.substring(0, index + 3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    dataValue: value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="动态修改-对象的某一个值及数组的某一项"><a href="#动态修改-对象的某一个值及数组的某一项" class="headerlink" title="动态修改 对象的某一个值及数组的某一项"></a>动态修改 对象的某一个值及数组的某一项</h4><blockquote><p>动态修改 数组 中的某一个值</p></blockquote><p>  通过对 需要改变的那一项的 ID判断 拿到当前的索引 拼接字符串 然后使用 <code>[需要更新的数组]：更新的数据</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const someId = &apos;3&apos;</span><br><span class="line">for (var i = 0; i &lt; that.data.DataList.length; i++) &#123;</span><br><span class="line">  if (that.data.DataList[i].id == someId) &#123;</span><br><span class="line">    let DataList = &apos;DataList[&apos; + [i] + &apos;].isSome&apos;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        [DataList]: true //或者其他值</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动态修改 对象中的某一个值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">  &apos;someObj.someValue&apos;: true //或者其他值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="动态显示倒计时-60秒-（获取验证码的提示秒数）"><a href="#动态显示倒计时-60秒-（获取验证码的提示秒数）" class="headerlink" title="动态显示倒计时 60秒 （获取验证码的提示秒数）"></a>动态显示倒计时 60秒 （获取验证码的提示秒数）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">that.setData(&#123;</span><br><span class="line">  seconds: 60,</span><br><span class="line">  timer: setInterval(function () &#123;</span><br><span class="line">    let seconds = that.data.seconds</span><br><span class="line">    that.setData(&#123; seconds: seconds - 1 &#125;)</span><br><span class="line">    if (that.data.seconds == 0) &#123;</span><br><span class="line">      clearInterval(that.data.timer)</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">      disabled: false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-一些js处理&quot;&gt;&lt;a href=&quot;#微信小程序-一些js处理&quot; class=&quot;headerlink&quot; title=&quot;微信小程序  一些js处理&quot;&gt;&lt;/a&gt;微信小程序  一些js处理&lt;/h3&gt;&lt;h4 id=&quot;input输入框输入数字时-只能输入小数点后两
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 返回上一页不刷新页面</title>
    <link href="http://gengaiwei.com/2020/07/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%8E%A7%E5%88%B6%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E4%B8%8A%E4%B8%80%E9%A1%B5%E6%95%B0%E6%8D%AE/"/>
    <id>http://gengaiwei.com/2020/07/22/微信小程序-控制是否更新上一页数据/</id>
    <published>2020-07-22T00:25:37.000Z</published>
    <updated>2020-07-27T05:50:06.791Z</updated>
    
    <content type="html"><![CDATA[<h4 id="当返回上一页时-判断是否需要刷新上一页"><a href="#当返回上一页时-判断是否需要刷新上一页" class="headerlink" title="当返回上一页时 判断是否需要刷新上一页"></a>当返回上一页时 判断是否需要刷新上一页</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>列表跳转详情 当从详情返回列表页面时 并不需要列表刷新 或其地方不需要刷新页面时</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>设置一个变量 借助页面栈的方式处理 由此变量判断当前页面是否需要刷新</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><blockquote><p>在列表页面 data中设置一个字段</p></blockquote><pre><code>如：isRefresh: true, // 刷新页面 true刷新 false不刷新</code></pre><blockquote><p>在返回 不需要刷新的页面前 获取下这时页面的栈</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">updateProData() &#123;</span><br><span class="line">  let pages = getCurrentPages(),</span><br><span class="line">    prevPage = pages[pages.length - 2]; //获取上一个页面</span><br><span class="line">    prevPage.setData(&#123;</span><br><span class="line">    isRefresh: true //修改上一个页面的变量</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;当返回上一页时-判断是否需要刷新上一页&quot;&gt;&lt;a href=&quot;#当返回上一页时-判断是否需要刷新上一页&quot; class=&quot;headerlink&quot; title=&quot;当返回上一页时 判断是否需要刷新上一页&quot;&gt;&lt;/a&gt;当返回上一页时 判断是否需要刷新上一页&lt;/h4&gt;&lt;h5 i
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序  使用vscode编辑器开发</title>
    <link href="http://gengaiwei.com/2020/07/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://gengaiwei.com/2020/07/11/微信小程序-使用vscode编辑器开发/</id>
    <published>2020-07-11T10:52:50.000Z</published>
    <updated>2020-07-24T08:59:53.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用vscode编辑器开发微信小程序"><a href="#使用vscode编辑器开发微信小程序" class="headerlink" title="使用vscode编辑器开发微信小程序"></a>使用vscode编辑器开发微信小程序</h3><blockquote><p>推荐安装插件</p></blockquote><table><thead><tr><th style="text-align:center">插件名</th><th style="text-align:left">主要功能</th></tr></thead><tbody><tr><td style="text-align:center">minapp</td><td style="text-align:left">wxml格式化、标签与属性自动补全及各种智能补全、内置snippets、js高亮等等</td></tr><tr><td style="text-align:center">wechat-snippets</td><td style="text-align:left">Wxml、js、json代码片段模版进行代码辅助，代码片段自动完成，可以作为minapp插件的补充。</td></tr><tr><td style="text-align:center">vscode-wechat</td><td style="text-align:left">微信应用支持vscode</td></tr><tr><td style="text-align:center">Vscode wxml</td><td style="text-align:left">提供wxml语法支持及代码片段</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用vscode编辑器开发微信小程序&quot;&gt;&lt;a href=&quot;#使用vscode编辑器开发微信小程序&quot; class=&quot;headerlink&quot; title=&quot;使用vscode编辑器开发微信小程序&quot;&gt;&lt;/a&gt;使用vscode编辑器开发微信小程序&lt;/h3&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript（一）：认知与基础类型</title>
    <link href="http://gengaiwei.com/2020/07/08/TypeScript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AE%A4%E7%9F%A5%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <id>http://gengaiwei.com/2020/07/08/TypeScript（一）：认知与基础类型/</id>
    <published>2020-07-08T06:22:11.000Z</published>
    <updated>2020-07-24T07:50:49.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TypeScript（一）：认知与基础类型"><a href="#TypeScript（一）：认知与基础类型" class="headerlink" title="TypeScript（一）：认知与基础类型"></a>TypeScript（一）：认知与基础类型</h3><p><img style="display: block; margin: 0 auto;" src="1.png" alt=""></p><blockquote><p>一、关于 TypeScript</p></blockquote><p><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 是 JavaScript 的一个<code>超集</code>，主要提供了类型系统和对 <code>ES6</code> 的支持，由 Microsoft 开发，代码开源于 GitHub 上。此处是<a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">中文文档</a></p><p><img style="display: block; margin: 0 auto;" src="2.png" alt=""></p><blockquote><p>二、TypeScript 的优缺点</p></blockquote><p><img src="3.png" alt="优点"><br><img src="4.png" alt="缺点"></p><blockquote><p>三、安装与编译</p></blockquote><ol><li><p>安装：</p><pre><code>npm install -g typescript 或者cnpm install -g typescript 或者yarn global add typescript </code></pre></li><li><p>编译：<br> <code>tsc helloworld.ts =&gt; helloworld.js</code> ts 文件是不能直接运行的，能运行的是 <code>js</code> 文件</p></li><li><p>自动编译：</p><pre><code>tsc --init //生成 tsconfig.json 然后：终端 &gt; 运行任务 &gt; tsc 监视</code></pre></li></ol><blockquote><p>四、TypeScript 的基础类型</p></blockquote><p>为了使编写的代码更规范，更有利于维护，增加了类型校验，在typescript中主要有以下类型：<br><img src="5.png" alt="类型总结图"></p><ul><li>Boolean 类型<br><img src="6.jpeg" alt="Boolean"></li><li>Number 类型<br><img src="7.jpeg" alt="Number"></li><li>String 类型<br><img src="8.jpeg" alt="String"></li><li>Array 类型<br><img src="9.jpeg" alt="Array"></li><li>Tuple 类型<br>  数组一般由同种类型的值组成，但有时需要在单个变量中存储不同类型的值时,就可以使用元组。<br>  元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值：<br><img src="10.jpeg" alt="Tuple"></li><li>Enum 类型<br>  使用枚举我们可以定义一些带名字的常量，方便清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</li><li>数字枚举<br>  <img src="11.jpeg" alt="Enum"><br>  默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。<br>  也可以设置 NORTH 的初始值：<br>  <img src="12.jpeg" alt="数字枚举"></li><li><p>字符串枚举<br>  在字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。<br>  <img src="13.jpeg" alt="字符串枚举"></p></li><li><p>异构枚举<br>  异构枚举的成员值是数字和字符串的混合：<br><img src="14.jpeg" alt="异构枚举"></p></li><li><p>Any 类型<br>  在 TypeScript 中，任何类型都可以被归为 <code>any</code> 类型。这让 <code>any</code> 类型成为了类型系统的顶级类型（也被称作<code>全局超级类型</code>）。<br>  <img src="15.jpeg" alt="Any"></p><pre><code>在许多场景下过于宽松，所以使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。   </code></pre></li><li><p>Void 类型</p><p>当一个函数没有返回值时，其返回值类型是 void：<br><img src="16.jpeg" alt="Void"></p></li></ul><p>但声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：<br><code>let unusable: void = undefined;</code></p><ul><li><p>Null 和 Undefined 类型</p><pre><code>在TypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。</code></pre></li></ul><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变，但，如果你指定了–<code>strictNullChecks</code> <code>标记，null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</p><ul><li><p>Never 类型<br>  never 类型表示的是那些永不存在的值的类型。 例如：会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。<br><img src="17.jpeg" alt="Never"><br>  可以利用 never 类型的特性来实现全面性检查：<br><img src="18.jpeg" alt="全面性检查"><br>假如后来有一天你的同事修改了 <code>WhatF</code> 的类型</p><pre><code>type WhatF = string | number | boolean;</code></pre><p>  使用 never 避免出现新增联合类型没有对应的情况，使类型更加健壮。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TypeScript（一）：认知与基础类型&quot;&gt;&lt;a href=&quot;#TypeScript（一）：认知与基础类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript（一）：认知与基础类型&quot;&gt;&lt;/a&gt;TypeScript（一）：认知与基础类型&lt;/
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://gengaiwei.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://gengaiwei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 使用 NPM</title>
    <link href="http://gengaiwei.com/2020/07/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8-NPM/"/>
    <id>http://gengaiwei.com/2020/07/07/微信小程序-使用-NPM/</id>
    <published>2020-07-07T10:59:00.000Z</published>
    <updated>2020-07-24T08:59:53.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、微信小程序-·-使用-NPM"><a href="#一、微信小程序-·-使用-NPM" class="headerlink" title="一、微信小程序 · 使用 NPM"></a>一、微信小程序 · 使用 NPM</h3><blockquote><p>一、如果按文档走：</p></blockquote><pre><code>执行命令安装： npm install工具 -&gt; 构建 npm</code></pre><p>⚠️ 没有找到 node_modules 目录的话：是由于npm 还没有初始化</p><blockquote><p>二、解决如下：</p></blockquote><ol><li><p>在小程序根目录下执行命令：</p><pre><code>npm init  生成 package.json文件</code></pre></li><li><p>在继续安装你要安装的第三方包：</p><pre><code>npm i vant-weapp -S --production</code></pre></li><li><p>开发工具</p><pre><code>工具 -&gt; 构建 npm</code></pre></li><li><p>详情里面</p><pre><code>选中使用 npm 模块</code></pre></li><li><p>改 app.json</p><pre><code>将 app.json 中的 &quot;style&quot;: &quot;v2&quot; 去除，小程序的新版基础组件强行加上了许多样式，难以去除，不关闭将造成部分组件样式混乱。</code></pre></li></ol><blockquote><p> 三、应用：</p></blockquote><pre><code>// 通过 npm 安装// app.json&quot;usingComponents&quot;: {&quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;}// 通过下载源码使用 es6版本// app.json&quot;usingComponents&quot;: {&quot;van-button&quot;: &quot;path/to/@vant/weapp/dist/button/index&quot;}// 通过下载源码使用 es5版本// app.json&quot;usingComponents&quot;: {&quot;van-button&quot;: &quot;path/to/@vant/weapp/lib/button/index&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、微信小程序-·-使用-NPM&quot;&gt;&lt;a href=&quot;#一、微信小程序-·-使用-NPM&quot; class=&quot;headerlink&quot; title=&quot;一、微信小程序 · 使用 NPM&quot;&gt;&lt;/a&gt;一、微信小程序 · 使用 NPM&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>性能优化篇（一）：函数防抖与截流</title>
    <link href="http://gengaiwei.com/2020/06/27/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E6%88%AA%E6%B5%81/"/>
    <id>http://gengaiwei.com/2020/06/27/性能优化篇（一）：函数防抖与截流/</id>
    <published>2020-06-27T10:43:10.000Z</published>
    <updated>2020-07-27T06:47:49.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数防抖与截流"><a href="#函数防抖与截流" class="headerlink" title="函数防抖与截流"></a>函数防抖与截流</h3><p>函数防抖，防止重复触发 延迟函数执行 并且不管触发多少次都只执行最后一次。</p><ul><li>（1） 第一次执行时，是一定能执行函数的。</li><li>（2） 然后 n秒内第二次触发的时候，当第一次与第二次间隔不足 设置的间隔时间时，就不会执行。之后第三、第四次触发还是不执行。</li><li>（3） 直到 n秒之后 有且仅有一次，并且是第一次再次触发函数。</li></ul><p>连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>函数节流 ：单位时间n秒内，第一次触发函数并执行，以后 n秒内不管触发多少次，都不执行。直到下一个单位时间n秒，第一次触发函数并执行，这个n秒内不管函数多少次都不执行。就是要 节约触发的频率 多用于页面scroll滚动，或者窗口resize，或者防止按钮重复点击等情况</p><ul><li><p>（1） 第一次触发函数时，定义了一个定时器。在 n秒后执行。</p></li><li><p>（2） 然后 函数第二次触发的时候，由于闭包的特性，这时候的 timer已经是第一次触发时的 定时器的标识了。然后直接清除第一次的setTimeout，这时候第一次的setTimeout里面的内容就不会执行了。然后再定义第二次的setTimeout。</p></li><li><p>（3） 然后重复第二个步骤，一直清除，又一直设置。直到函数最后一次触发，定义了最后的一个定时器，并且间隔 n秒 执行。</p></li><li><p>（4） 如果在 最后一个定时器没执行时，函数又触发了，那么又重复第三步。相当于 设置的间隔时间，只是延迟函数执行的时间，而不是间隔多少秒再执行。</p></li></ul><p>间隔一段时间执行一次回调的场景有</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>谷歌搜索框，搜索联想功能</li><li>高频点击提交，表单重复提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clickTab: tool.throttle(function(e) &#123;</span><br><span class="line">   var _this = this;</span><br><span class="line">   if (this.data.currentTab === e[0].currentTarget.dataset.current) &#123;</span><br><span class="line">     return false</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">       currentTab: e[0].currentTarget.dataset.current</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数防抖与截流&quot;&gt;&lt;a href=&quot;#函数防抖与截流&quot; class=&quot;headerlink&quot; title=&quot;函数防抖与截流&quot;&gt;&lt;/a&gt;函数防抖与截流&lt;/h3&gt;&lt;p&gt;函数防抖，防止重复触发 延迟函数执行 并且不管触发多少次都只执行最后一次。&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="性能优化" scheme="http://gengaiwei.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="http://gengaiwei.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 App.js写点什么</title>
    <link href="http://gengaiwei.com/2020/06/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-app-js%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/"/>
    <id>http://gengaiwei.com/2020/06/20/微信小程序-app-js写点什么/</id>
    <published>2020-06-20T10:45:28.000Z</published>
    <updated>2020-07-27T06:07:52.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守望角"><a href="#守望角" class="headerlink" title="守望角"></a>守望角</h3><p>作为微信小程序的入口文件，它就站在那个角上，一动不动，那就把它称为 守望角 吧，一个无私奉献的爱的 App.js是那么的惹人注目，嗯。</p><p>整个小程序只有一个它 App 实例，由全部页面共享 开发者可以毫不留情的通过 <code>getApp</code> 方法获取到全局唯一的 App 实例，获取App上的 数据 或 调用开发者注册在 App 上的函数。你要的全拿走～</p><blockquote><p>某个页面获取App.js中的数据</p></blockquote><p>只需要在使用的页面 引入 即可 <code>const app = getApp()</code></p><blockquote><p>登录验证</p></blockquote><p>无论是 <code>wx.login</code> 还是 用户输入账号密码的登录 在进行实际业务前 需要确定下用户的登录状态 包括验证 <code>session_key</code>是否过期 是否需要重新执行登录流程等</p><p>如果在app.js中写了登录的方法，但登录执行的返回结果 需要执行完之后 再执行首页的方法 其实更建议把登录的方法封装到某个js文件里<br><a href="/source/_posts/wx-login.md">这是在app.js中写的登录</a></p><blockquote><p>机型判断</p></blockquote><p>可能项目中有 针对<code>iOS</code> 或者 <code>Android</code> 的bug处理；又或者是业务处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.getSystemInfo().then(res =&gt; &#123;</span><br><span class="line">  console.log(res.system);</span><br><span class="line">  this.globalData.isIOS = res.system.indexOf(&apos;iOS&apos;) &gt; -1 ? true : false;//根据业务自行存储处理</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><blockquote><p>判断是否为全屏</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checkFullSucreen: function() &#123;</span><br><span class="line">  let that = this;</span><br><span class="line">  wx.getSystemInfo(&#123;</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      // 根据 屏幕高度 进行判断</span><br><span class="line">      if (res.screenHeight - res.windowHeight - res.statusBarHeight - 32 &gt; 72) &#123;</span><br><span class="line">        that.globalData.isFullScreen = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>版本更新提示</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const updateManager = wx.getUpdateManager();</span><br><span class="line">updateManager.onUpdateReady(function() &#123;</span><br><span class="line">  wx.showModal(&#123;</span><br><span class="line">    title: &apos;更新提示&apos;,</span><br><span class="line">    content: &apos;新版本已经准备好，是否重启应用？&apos;,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      if (res.confirm) &#123;</span><br><span class="line">        updateManager.applyUpdate();// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>待续。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;守望角&quot;&gt;&lt;a href=&quot;#守望角&quot; class=&quot;headerlink&quot; title=&quot;守望角&quot;&gt;&lt;/a&gt;守望角&lt;/h3&gt;&lt;p&gt;作为微信小程序的入口文件，它就站在那个角上，一动不动，那就把它称为 守望角 吧，一个无私奉献的爱的 App.js是那么的惹人注目，嗯
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-数组的骚操作</title>
    <link href="http://gengaiwei.com/2020/05/27/javascript-%E6%95%B0%E7%BB%84%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://gengaiwei.com/2020/05/27/javascript-数组的骚操作/</id>
    <published>2020-05-26T16:00:00.000Z</published>
    <updated>2020-07-27T06:33:58.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="其实这是个-备忘录-📕"><a href="#其实这是个-备忘录-📕" class="headerlink" title="其实这是个 备忘录 📕"></a>其实这是个 备忘录 📕</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;其实这是个-备忘录-📕&quot;&gt;&lt;a href=&quot;#其实这是个-备忘录-📕&quot; class=&quot;headerlink&quot; title=&quot;其实这是个 备忘录 📕&quot;&gt;&lt;/a&gt;其实这是个 备忘录 📕&lt;/h3&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://gengaiwei.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://gengaiwei.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 使用全局CSS</title>
    <link href="http://gengaiwei.com/2020/05/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A8%E5%B1%80CSS/"/>
    <id>http://gengaiwei.com/2020/05/04/微信小程序全局CSS/</id>
    <published>2020-05-04T10:45:12.000Z</published>
    <updated>2020-07-27T06:03:59.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何让使用全局CSS"><a href="#如何让使用全局CSS" class="headerlink" title="如何让使用全局CSS"></a>如何让使用全局CSS</h3><blockquote><p>1、使用全局的app.css</p></blockquote><ul><li>app.wxss 是全局样式文件，对每个页面都起作用 如果某个页面不想要这个样式可以在那个页面再单独定义样式覆盖全局默认样式;</li><li>微信小程序样式可以 <code>@import</code>其他样式文件;</li><li>微信小程序样式 和 CSS 一样;</li><li>支持常用的 <code>:after,:before</code>, :<code>first-child</code> , <code>nth-child</code> 等常用伪劣选择器.</li></ul><blockquote><p>2、引入其他样式文件</p></blockquote><pre><code>使用 @import 导入外联样式表，@import 使用 外联样式表的相对路径在公共文件中创建demo.wxss文件后直接在所需要引入的wxss文件中引入 或者在app.wxss中引入@import &quot;demo.wxss“;</code></pre><blockquote><p>3、常用支持的选择器</p></blockquote><table><thead><tr><th>选择器</th><th style="text-align:center">demo</th></tr></thead><tbody><tr><td>类选择器</td><td style="text-align:center">.class</td></tr><tr><td>ID选择器</td><td style="text-align:center">#id</td></tr><tr><td>标签选择器</td><td style="text-align:center">view</td></tr><tr><td>后代选择器</td><td style="text-align:center">.class .child-class</td></tr><tr><td>:after</td><td style="text-align:center">view:after</td></tr><tr><td>:before</td><td style="text-align:center">view:before</td></tr><tr><td>:first-child</td><td style="text-align:center">view:first-child</td></tr><tr><td>:last-child</td><td style="text-align:center">view:last-child</td></tr><tr><td>:nth-child</td><td style="text-align:center">view:nth-child(even) view:nth-child(odd)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何让使用全局CSS&quot;&gt;&lt;a href=&quot;#如何让使用全局CSS&quot; class=&quot;headerlink&quot; title=&quot;如何让使用全局CSS&quot;&gt;&lt;/a&gt;如何让使用全局CSS&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、使用全局的app.css&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 下载查看PDF</title>
    <link href="http://gengaiwei.com/2020/03/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%B8%8B%E8%BD%BD%E6%9F%A5%E7%9C%8BPDF/"/>
    <id>http://gengaiwei.com/2020/03/10/微信小程序-下载查看PDF/</id>
    <published>2020-03-10T11:17:07.000Z</published>
    <updated>2020-07-27T06:03:28.339Z</updated>
    
    <content type="html"><![CDATA[<h4 id="下载查看PDF"><a href="#下载查看PDF" class="headerlink" title="下载查看PDF"></a>下载查看PDF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">checkPDF: function () &#123;</span><br><span class="line">  wx.downloadFile(&#123;</span><br><span class="line">    url: &apos;https://***.png&apos;,      //要预览的PDF的地址</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">      if (res.statusCode === 200) &#123;                     //成功</span><br><span class="line">        var Path = res.tempFilePath                     //返回的文件临时地址，用于后面打开本地预览所用</span><br><span class="line">        wx.openDocument(&#123;</span><br><span class="line">          filePath: Path,                               //要打开的文件路径</span><br><span class="line">          success: function (res) &#123;</span><br><span class="line">            console.log(&apos;打开PDF成功&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function (res) &#123;</span><br><span class="line">      console.log(res);                                  //失败</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;下载查看PDF&quot;&gt;&lt;a href=&quot;#下载查看PDF&quot; class=&quot;headerlink&quot; title=&quot;下载查看PDF&quot;&gt;&lt;/a&gt;下载查看PDF&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 支付功能</title>
    <link href="http://gengaiwei.com/2020/02/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/"/>
    <id>http://gengaiwei.com/2020/02/20/微信小程序-支付功能/</id>
    <published>2020-02-20T10:59:29.000Z</published>
    <updated>2020-07-27T05:17:58.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-使用支付功能"><a href="#微信小程序-使用支付功能" class="headerlink" title="微信小程序 使用支付功能"></a>微信小程序 使用支付功能</h3><p>步骤如下：</p><blockquote><p>需要 openid  由登录API code 换取</p></blockquote><p>此 openid 通过 <code>wx.login</code> 获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  success: res =&gt; &#123;</span><br><span class="line">    // 发送 res.code 到后台换取 openId, sessionKey, unionId</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>数据签名：五个必填字段签名(区分大小写) 需要后台接口返回以下数据</p></blockquote><ul><li>timeStamp   时间戳  从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间</li><li>nonceStr 随机字符串， 长度为32个字符以下 </li><li>Package  数据包 统一下单接口返回的 prepay_id 参数值 提交格式如：prepay_id=***</li><li>signType 签名算法  默认 “MD5”</li><li>paySign  签名 </li></ul><p>实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.requestPayment(&#123;</span><br><span class="line">  timeStamp: &apos;&apos;,</span><br><span class="line">  nonceStr: &apos;&apos;,</span><br><span class="line">  package: &apos;&apos;,</span><br><span class="line">  signType: &apos;MD5&apos;,</span><br><span class="line">  paySign: &apos;&apos;,</span><br><span class="line">  success (res) &#123; &#125;,</span><br><span class="line">  fail (res) &#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>调起支付页面的协议需要是 <code>https</code></p></blockquote><table><tr><td bgcolor="pink"><em>注 ：使用前提 首先需要在公众平台开通申请 微信支付 而且需要小程序已发布上线或者有已经关联的线上公众号、小程序</em></td></tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-使用支付功能&quot;&gt;&lt;a href=&quot;#微信小程序-使用支付功能&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 使用支付功能&quot;&gt;&lt;/a&gt;微信小程序 使用支付功能&lt;/h3&gt;&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要 o
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue Cli 3.x项目构建与开发</title>
    <link href="http://gengaiwei.com/2020/02/01/vueproject/"/>
    <id>http://gengaiwei.com/2020/02/01/vueproject/</id>
    <published>2020-02-01T03:05:25.000Z</published>
    <updated>2020-07-27T07:06:42.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue-Cli-3-x-项目构建与开发"><a href="#Vue-Cli-3-x-项目构建与开发" class="headerlink" title="Vue Cli 3.x 项目构建与开发"></a>Vue Cli 3.x 项目构建与开发</h3><p>这里是<a href="https://github.com/DavidGAW/vue-cli3.x-test" target="_blank" rel="noopener">GitHub项目地址</a></p><h4 id="一、脚手架-CLI-的理解"><a href="#一、脚手架-CLI-的理解" class="headerlink" title="一、脚手架 CLI 的理解"></a>一、脚手架 CLI 的理解</h4><blockquote><p>脚手架 CLI，是一个命令行工具，它的出现主要解决这几个问题：</p></blockquote><ul><li>减少重复性工作</li><li>规范项目开发目录结构</li><li>统一团队统一开发风格，便于跨团队合作，以及后期维护，降低新人上手成本</li><li>提供一键前端项目的创建、配置、本地开发、插件扩展等功能，让开发者更多时间专注于业务</li></ul><h4 id="二、CLI的基本功能"><a href="#二、CLI的基本功能" class="headerlink" title="二、CLI的基本功能"></a>二、CLI的基本功能</h4><blockquote><p>搭建项目</p></blockquote><ul><li>根据用户输入生成配置文件</li><li>下载指定项目模板</li><li>在目标目录生成新项目</li></ul><blockquote><p>运行项目</p></blockquote><ul><li>本地启动预览</li><li>热更新</li><li>语法、代码规范检测</li><li>代码推送至仓库</li><li>前端部署的管理后台去进行发布（自动打包）</li></ul><h4 id="三、CLI的安装"><a href="#三、CLI的安装" class="headerlink" title="三、CLI的安装"></a>三、CLI的安装</h4><p>这里选择的是自定义安装：</p><ul><li>依赖工具：node、 npm    </li><li>安装 Vue CLI 3.x命令 ：npm i -g @vue/cli</li><li>构建 vue create my-project</li><li>可选默认 / 推荐自定义 TS、 Babel、Router、 Vuex、CSS Pre-processors 等</li></ul><p>示例如下：</p><p><img src="1.png" alt=""><br><img src="2.png" alt=""><br><em>注：除上述命令构建外 还可用 vue ui 可视化 进行构建</em><br>生成目录 （选择的配置不同目录也会有差异）<br><img src="3.png" alt=""></p><h4 id="四、NPM包管理与配置项"><a href="#四、NPM包管理与配置项" class="headerlink" title="四、NPM包管理与配置项"></a>四、NPM包管理与配置项</h4><ol><li><p>配置项：一系列键值对构成的 JSON 对象，每一个键值对都有其相应的作用</p></li><li><p>包管理常用命令：<code>npm init</code>、<code>npm init -y</code>、<code>npm i</code>、<code>npm i xxx</code>、<code>npm i xxx —-save</code>、<code>npm i xxx --save-dev</code>、<code>npm i -g xxx</code>、<code>npm run xxx</code></p></li><li><p><code>vue-cli 3.x</code> 还提供了其专属的 <code>vue ad</code>d 命令：以<code>@vue/cli-plugin</code> 或者 <code>vue-cli-plugin</code> 开头， 只能安装 Vue 集成的包（两个特例：<code>vue add router</code>、<code>vue add vuex</code>），同时， <code>vue add</code> 不仅会将包安装到你的项目中，其还会改变项目的代码或文件结构，所以安装前最好提交你的代码至仓库</p></li></ol><h4 id="五、webpack在cli3-x"><a href="#五、webpack在cli3-x" class="headerlink" title="五、webpack在cli3.x"></a>五、webpack在cli3.x</h4><ol><li>与cli2.x中的差异<br><img src="4.png" alt=""></li><li>开箱即用，无需配置 webpack 就可以运行项目，并且提供了 vue.config.js 文件来满足开发者对其封装的 webpack 默认配置的修改 如果项目目录中没有此文件 新建即可；<br><img src="5.png" alt=""><br><em>参考：<a href="https://github.com/vuejs/vue-cli/blob/ce3e2d475d63895cbb40f62425bb6b3237469bcd/docs/zh/config/README.md" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/blob/ce3e2d475d63895cbb40f62425bb6b3237469bcd/docs/zh/config/README.md</a></em></li><li>默认插件：vue-cli 3.x 为我们默认封装了项目运行的常用 webpack 配置，它给我们提供了默认插件，每一个 plugin的用途 除了使用 vue inspect plugins  查看 还可以通过运行 vue ui 进入可视化页面查看(tasks =&gt;inspect=&gt;run task)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// vue-loader是 webpack 的加载器，允许你以单文件组件的格式编写 Vue 组件</span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin’);</span><br><span class="line">// webpack 内置插件，用于创建在编译时可以配置的全局常量</span><br><span class="line">const &#123; DefinePlugin &#125; = require(&apos;webpack’);</span><br><span class="line">// 用于强制所有模块的完整路径必需与磁盘上实际路径的确切大小写相匹配</span><br><span class="line">const CaseSensitivePathsPlugin = require(&apos;case-sensitive-paths-webpack-plugin’);</span><br><span class="line">// 识别某些类型的 webpack 错误并整理，以提供开发人员更好的体验。</span><br><span class="line">const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;); </span><br><span class="line">// 用于根据模板或使用加载器生成 HTML 文件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin’);</span><br><span class="line">// 用于在使用 html-webpack-plugin 生成的 html 中添加 &lt;link rel =&apos;preload&apos;&gt; 或 &lt;link rel =&apos;prefetch&apos;&gt;，有助于异步加载</span><br><span class="line">const PreloadPlugin = require(&apos;preload-webpack-plugin&apos;);</span><br></pre></td></tr></table></figure><h4 id="六、env文件与环境配置"><a href="#六、env文件与环境配置" class="headerlink" title="六、env文件与环境配置"></a>六、env文件与环境配置</h4><blockquote><p>在实际项目的开发中一般会经历项目的开发阶段、测试阶段和最终上线阶段，每一个阶段对于项目代码的要求可能都不尽相同，那么我们如何能够游刃有余的在不同阶段下使我们的项目呈现不同的效果，使用不同的功能呢？这里就需要引入环境的概念。</p></blockquote><p>一般一个项目都会有以下 3 种环境</p><ul><li>开发环境（开发阶段，本地开发版本，一般会使用一些调试工具或额外的辅助功能）</li><li>测试环境（测试阶段，上线前版本，除了一些 bug 的修复，基本不会和上线版本有很大差别）</li><li>生产环境（上线阶段，正式对外发布的版本，一般会进行优化，关掉错误报告）</li></ul><h5 id="6-1-如何配置"><a href="#6-1-如何配置" class="headerlink" title="6.1 如何配置"></a>6.1 如何配置</h5><blockquote><p>默认在配置之前 需要清楚配置的环境关系<br>生产环境配置、开发环境配置、测试环境配置、公共配置<br>存在交集 也就是有公共配置 那么如何处理：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env # 在所有的环境中被载入</span><br><span class="line">.env.local# 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode] # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p>比如我们创建一个名为 .env.stage 的文件，该文件表明其只在 stage 环境下被加载，在这个文件中，我们可以配置如下键值对的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage </span><br><span class="line">VUE_APP_TITLE=stage mode</span><br></pre></td></tr></table></figure></p><p>然后在修改 package.json 中的 serve 脚本的命令为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;vue-cli-service serve --mode stage&quot;</span><br></pre></td></tr></table></figure></p><p>其实是修改了 webpack 4 中的 mode 配置项为 stage，同时其会读取对应 .env.[model] 文件下的配置，如果没找到对应配置文件，就会用默认环境 development </p><h5 id="6-2-环境注入"><a href="#6-2-环境注入" class="headerlink" title="6.2 环境注入"></a>6.2 环境注入</h5><blockquote><p>vue-cli 3.x 封装的 webpack 配置中已经完成了这个功能，所以我们可以直接在客户端代码中打印出 process.env 的值</p></blockquote><p><img src="6.png" alt=""></p><p>输出内容除了我们环境配置中的变量外还包含了很多 npm 的信息，但是我们在入口文件 main.js 中打印会发现输出</p><p><img src="7.png" alt=""><br>过滤调了非 VUE_APP_ 开头的变量 是因为webpack 通过 DefinePlugin 内置插件将 process.env 注入到客户端代码中。</p><h5 id="6-3-额外配置"><a href="#6-3-额外配置" class="headerlink" title="6.3 额外配置"></a>6.3 额外配置</h5><blockquote><p>以上通过新建配置文件的方式为项目不同环境配置不同的变量值，能够实现项目基本的环境管理，但是 .env 这样的配置文件中的参数目前只支持静态值，无法使用动态参数，当需要实现特定的需求时（如在非生产环境我们可以给自己的移动端项目开启 vConsole 调试/配置中的 BASE_URL 来设置路由的 base 参数），可以在根目录下新建 config 文件夹用于存放一些额外的配置文件。</p></blockquote><p><img src="8.png" alt=""></p><p>把环境变量分为了公共变量、开发环境变量和生产环境变量，当然这些变量可能是动态的，比如门店/用户的IP 等。现在我们要在 vue.config.js 里注入这些变量，我们可以使用 chainWebpack 修改 DefinePlugin 中的值：</p><p><img src="9.png" alt=""></p><p>成功打印</p><p><img src="10.png" alt=""></p><p>环境的配置和管理对于项目的构建起到了至关重要的作用，通过给项目配置不同的环境不仅可以增加开发的灵活性、提高程序的拓展性，同时也有助于帮助我们去了解并分析项目在不同环境下的运行机制，建立全局观念。</p><h4 id="七、页面内部配置"><a href="#七、页面内部配置" class="headerlink" title="七、页面内部配置"></a>七、页面内部配置</h4><blockquote><p>前面部分主要说的是项目构建及运行的前期工作，像webpack 的配置、环境变量的使用等，接下来，走进vue项目的内部，理解内部配置的基本构成。</p></blockquote><p><img src="11.png" alt=""></p><h5 id="7-1-Vue-基本配置：-路由配置-src-gt-router-gt-index-js"><a href="#7-1-Vue-基本配置：-路由配置-src-gt-router-gt-index-js" class="headerlink" title="7.1 Vue 基本配置： 路由配置 src -&gt; router -&gt; index.js"></a>7.1 Vue 基本配置： 路由配置 src -&gt; router -&gt; index.js</h5><p>最基础的路由配置，有以下几点需要进行优化：</p><ul><li>如果路由存在二级目录，需要添加 base 属性，否则默认为 “/“</li><li>默认路由模式是 hash 模式，会携带 # 标记，与真实 url 不符，可以改为 history 模式</li><li>页面组件没有进行按需加载，可以使用 require.ensure() 来进行优化、import 语法来进行代码分块、Magic Comments、</li></ul><h5 id="7-2-vuex-配置-src-gt-store-gt-index-js"><a href="#7-2-vuex-配置-src-gt-store-gt-index-js" class="headerlink" title="7.2 vuex 配置: src -&gt; store -&gt; index.js"></a>7.2 vuex 配置: src -&gt; store -&gt; index.js</h5><blockquote><p>专门为vuejs应用程序开发的状态管理模式 </p></blockquote><p>主要四个部分 ：<br>        <code>state</code> <code>mutations</code> <code>actions</code> <code>getter</code></p>  <table><tr><td bgcolor="orange">通过 actions 异步提交 mutations 去 修改 state 的值并通过 getter 获取。</td></tr></table><p>vuex适合中大型项目，用来管理错综复杂的状态数据是很有帮助的，而为了后期的拓展性和可维护性，不建议使用 CLI 生成的一份配置文件来管理所有的状态操作，我们可以把它拆分为以下目录：</p><p><img src="12.png" alt=""></p><p><em>项目中状态的模块划分就更加清晰，对应模块的状态我们只需要修改相应模块文件即可</em></p><h5 id="7-3-接口配置-src-gt-services-gt-http-js-etc"><a href="#7-3-接口配置-src-gt-services-gt-http-js-etc" class="headerlink" title="7.3 接口配置:src -&gt; services -&gt; http.js etc"></a>7.3 接口配置:src -&gt; services -&gt; http.js etc</h5><blockquote><p>在 src 目录下新建 services 文件夹用于存放接口文件<br>并可以使用不同的文件来配置不同模块的接口，同时由于接口的调用 ajax 请求代码重复部分较多，可以对其进行简单的封装 =&gt;http.js</p></blockquote><h5 id="7-4-公共设施配置-src-gt-common-gt-index-js-validate-js-etc"><a href="#7-4-公共设施配置-src-gt-common-gt-index-js-validate-js-etc" class="headerlink" title="7.4 公共设施配置:src -&gt; common -&gt; index.js/validate.js etc"></a>7.4 公共设施配置:src -&gt; common -&gt; index.js/validate.js etc</h5><blockquote><p>在项目开发中肯定需要对一些公共的方法进行封装使用，这里把它称之为公共设施，那么我们可以在 src 目录下建一个 common 文件夹来存放其配置文件：<br>只需要在入口文件向外暴露其他功能配置的模块，在页面中只需要引入一个index.js 即可</p></blockquote><h4 id="八、开发工具的扩充"><a href="#八、开发工具的扩充" class="headerlink" title="八、开发工具的扩充"></a>八、开发工具的扩充</h4><p>1、vue.js devtools</p><ul><li>作用： Vue 官方发布的一款调试 Vue 项目的插件，支持数据模拟与调试</li><li>安装：<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN</a></li></ul><p>2、Vue performance devtool</p><ul><li>作用： 可以分析我们页面中各个组件的性能情况，从而在其基础上我们可以有针对性的对组件的代码进行优化 </li><li>安装：<a href="https://chrome.google.com/webstore/detail/vue-performance-devtool/koljilikekcjfeecjefimopfffhkjbne" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/vue-performance-devtool/koljilikekcjfeecjefimopfffhkjbne</a></li></ul><p>3、FeHelper</p><ul><li>作用： 是百度 FE 团队开发的一款前端工具集插件，包含代码压缩／性能检测／字符串编解码等功能，能够帮助我们完成一些琐碎的开发任务。</li><li>安装：<a href="https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue-Cli-3-x-项目构建与开发&quot;&gt;&lt;a href=&quot;#Vue-Cli-3-x-项目构建与开发&quot; class=&quot;headerlink&quot; title=&quot;Vue Cli 3.x 项目构建与开发&quot;&gt;&lt;/a&gt;Vue Cli 3.x 项目构建与开发&lt;/h3&gt;&lt;p&gt;这里
      
    
    </summary>
    
      <category term="Vue" scheme="http://gengaiwei.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://gengaiwei.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>git分支使用</title>
    <link href="http://gengaiwei.com/2019/04/02/gitBranch/"/>
    <id>http://gengaiwei.com/2019/04/02/gitBranch/</id>
    <published>2019-04-02T12:46:03.000Z</published>
    <updated>2019-12-03T09:30:14.729Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Git" scheme="http://gengaiwei.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hi Man</title>
    <link href="http://gengaiwei.com/2018/10/11/hello-world/"/>
    <id>http://gengaiwei.com/2018/10/11/hello-world/</id>
    <published>2018-10-11T07:20:30.796Z</published>
    <updated>2018-10-11T07:20:30.797Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><img src="/h.png" alt="Alt text"></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://gengaiwei.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 分类 提交后台返回的分类ID</title>
    <link href="http://gengaiwei.com/2018/03/10/wxPicker/"/>
    <id>http://gengaiwei.com/2018/03/10/wxPicker/</id>
    <published>2018-03-10T06:40:49.000Z</published>
    <updated>2020-07-27T06:01:48.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Form表单中-分类选项，选中之后，得到后台返回的ID，这里是GitHub"><a href="#Form表单中-分类选项，选中之后，得到后台返回的ID，这里是GitHub" class="headerlink" title="Form表单中 分类选项，选中之后，得到后台返回的ID，这里是GitHub"></a>Form表单中 分类选项，选中之后，得到后台返回的ID，这里是<a href="https://github.com/DavidGAW/wx-picker" target="_blank" rel="noopener">GitHub</a></h3><blockquote><p>1.wxml</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;picker bindchange=&quot;bindCategory&quot;  </span><br><span class="line">        name=&quot;category_id&quot;</span><br><span class="line">        value=&quot;&#123;&#123;category_index&#125;&#125;&quot;</span><br><span class="line">        range=&quot;&#123;&#123;category&#125;&#125;&quot; &gt;</span><br><span class="line">    &lt;view class=&quot;picker&quot; &gt;</span><br><span class="line">        &lt;text style=&apos;color:#888;padding-right:5%;&apos;&gt;分类&lt;/text&gt;</span><br><span class="line">        &#123;&#123;category[category_index]&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;image class=&apos;dowm-btn&apos; src=&apos;一个向下箭头的图片&apos;&gt;&lt;/image&gt;</span><br><span class="line">&lt;/picker&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2.wxss</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.fl&#123;</span><br><span class="line">    background: #fff;</span><br><span class="line">    height: 45px;</span><br><span class="line">    line-height: 45px;</span><br><span class="line">    padding-left: 5%;</span><br><span class="line">    font-size: 0.8rem;</span><br><span class="line">&#125;</span><br><span class="line">.picker&#123;</span><br><span class="line">    width: 85%;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.dowm-btn&#123;</span><br><span class="line">    width: 1rem;</span><br><span class="line">    height: 1rem;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.js 这里只是得到了选中的本身自带的ID，可能并不是后台给你的ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bindCategory: function (e) &#123;</span><br><span class="line">    var that =this</span><br><span class="line">    that.setData(&#123;</span><br><span class="line">    category_index: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>4.一般的选择分类，一般都是包含在一个大的表单里，要提交到后台提供的接口里</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;form bindsubmit=&apos;submitForm&apos;&gt;</span><br><span class="line">    //这里包含各种表单，for example：input ,checkbox ,radio etc.</span><br><span class="line"></span><br><span class="line">    &lt;picker bindchange=&quot;bindCategory&quot;  </span><br><span class="line">            name=&quot;category_id&quot;</span><br><span class="line">            value=&quot;&#123;&#123;category_index&#125;&#125;&quot;</span><br><span class="line">            range=&quot;&#123;&#123;category&#125;&#125;&quot; &gt;</span><br><span class="line">        &lt;view class=&quot;picker&quot; &gt;</span><br><span class="line">            &lt;text style=&apos;color:#888;padding-right:5%;&apos;&gt;分类&lt;/text&gt;</span><br><span class="line">            &#123;&#123;category[category_index]&#125;&#125;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">        &lt;image class=&apos;dowm-btn&apos; src=&apos;一个向下箭头的图片&apos;&gt;&lt;/image&gt;</span><br><span class="line">    &lt;/picker&gt;</span><br><span class="line"></span><br><span class="line">    &lt;view class=&apos;submitForm&apos;&gt;</span><br><span class="line">        &lt;button class=&apos;submitbtn&apos; form-type=&apos;submit&apos; &gt;发布&lt;/button&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><blockquote><p>5.选取分类，得到的ID是当前标签本身的index，并不是后台返回的ID 在分类的接口回调中，把分类的name与ID分别存下来，然后，在提交表单的时候，把当前分类自带的ID替换为后台提供的ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">    url: ‘分类接口&apos;,</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    header: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">        Token: wx.getStorageSync(&apos;openid&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">        let category = res.data.data</span><br><span class="line">        let id_arr=[];</span><br><span class="line">        let name_arr = [];</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; category.length; i++) &#123;</span><br><span class="line">        id_arr[i] = category[i].id</span><br><span class="line">        name_arr[i] = category[i].name;</span><br><span class="line">        &#125;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">        category: name_arr,</span><br><span class="line">        category_idlist: id_arr</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function (res) &#123;</span><br><span class="line">        wx.hideLoading();</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">            title: &apos;加载失败&apos;,</span><br><span class="line">            icon: &apos;err&apos;,</span><br><span class="line">            duration: 2000</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>6.在提交表单时，更换为后台提供的分类对应的ID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">submitForm: function (e) &#123;</span><br><span class="line">    let that = this;</span><br><span class="line"></span><br><span class="line">    e.detail.value.category_id = that.data.category_idlist[e.detail.value.category_id];</span><br><span class="line"></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">        url: ‘提交表单的接口&apos;,</span><br><span class="line">        method: &apos;POST&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            category_id: e.detail.value.category_id,</span><br><span class="line">        &#125;,</span><br><span class="line">        header: &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">            Token: wx.getStorageSync(&apos;openid&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        success: function (res) &#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: function (res) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>如果对你有用，谢谢 Star一下<a href="https://github.com/DavidGAW/wx-picker" target="_blank" rel="noopener">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Form表单中-分类选项，选中之后，得到后台返回的ID，这里是GitHub&quot;&gt;&lt;a href=&quot;#Form表单中-分类选项，选中之后，得到后台返回的ID，这里是GitHub&quot; class=&quot;headerlink&quot; title=&quot;Form表单中 分类选项，选中之后，
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 轮播图/跑马灯</title>
    <link href="http://gengaiwei.com/2018/03/08/wxSwiper/"/>
    <id>http://gengaiwei.com/2018/03/08/wxSwiper/</id>
    <published>2018-03-08T08:20:14.000Z</published>
    <updated>2020-07-24T08:59:53.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动"><a href="#Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动" class="headerlink" title="Swiper 轮播图 也可做成跑马灯 就像信息提示/公告 在这里都是左右滚动"></a>Swiper 轮播图 也可做成跑马灯 就像信息提示/公告 在这里都是左右滚动</h3><blockquote><p>1.swiper 轮播图 wxml</p></blockquote><pre><code>&lt;view class=&apos;lunBo&apos;&gt;    &lt;swiper class=&apos;swiper&apos; indicator-dots=&apos;true&apos; autoplay=&apos;true&apos; interval=&apos;3000&apos; duration=&apos; 200&apos; circular=&apos;true&apos;&gt;        &lt;block wx:for=&quot;{{lunBoimgUrls}}&quot; wx:key=&quot;&quot;&gt;            &lt;swiper-item&gt;                &lt;image src=&quot;{{item}}&quot; class=&quot;lunBo-image&quot; /&gt;            &lt;/swiper-item&gt;        &lt;/block&gt;    &lt;/swiper&gt;&lt;/view&gt;</code></pre><blockquote><p>2.swiper 跑马灯 wxml</p></blockquote><pre><code>&lt;!--跑马灯  --&gt;&lt;view class=&apos;share-tips&apos;&gt;    &lt;view class=&apos;my-center&apos;&gt;        &lt;text class=&apos;tips-f&apos;&gt;公告：&lt;/text&gt;         &lt;swiper class=&apos;tips-k&apos;  autoplay  interval=&apos;5000&apos; duration=&apos;3000&apos; circular=&apos;true&apos; &gt;            &lt;swiper-item wx:key=&quot;&quot; wx:for=&apos;{{tipsText}}&apos;&gt;                &lt;view&gt;{{item}}&lt;/view&gt;            &lt;/swiper-item&gt;        &lt;/swiper&gt;    &lt;/view&gt;&lt;/view&gt;</code></pre><blockquote><p>3.swiper 轮播图/跑马灯 wxss</p></blockquote><pre><code>.lunBo-k{height: 0px;}.lunBo{position: absolute;top:-54px;left: 0px;width: 100%;height: 158px;border-radius: 8px;}.lunBo swiper {height: 100%;}.lunBo swiper swiper-item{width: 100%;border-radius: 8px; }.lunBo-image{width: 100%;height: 158px; border-radius: 8px; }.tips-f{width: 20%;font-size: 0.6rem;height: 24px;line-height: 24px;float: left;}.tips-k{width: 80%;height: 24px;overflow: hidden;font-size: 12px;display: inline-block;}</code></pre><blockquote><p>4.swiper 轮播图/跑马灯 js</p></blockquote><pre><code>data: {    lunBoimgUrls: [    &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&apos;,    &apos;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&apos;,    &apos;http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg&apos;,    ],    tipsText: [    &apos;我是第一条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    &apos;我是第二条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    &apos;我是第三条滚动的啊哈哈哈哈哈哈哈哈哈&apos;,    ],},</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动&quot;&gt;&lt;a href=&quot;#Swiper-轮播图-也可做成跑马灯-就像信息提示-公告-在这里都是左右滚动&quot; class=&quot;headerlink&quot; title=&quot;Swiper 轮播图 也可做成跑
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 评论留言功能</title>
    <link href="http://gengaiwei.com/2018/03/06/wx-comment/"/>
    <id>http://gengaiwei.com/2018/03/06/wx-comment/</id>
    <published>2018-03-06T06:52:24.000Z</published>
    <updated>2020-07-24T08:59:53.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序-评论留言功能"><a href="#微信小程序-评论留言功能" class="headerlink" title="微信小程序 评论留言功能"></a>微信小程序 评论留言功能</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序-评论留言功能&quot;&gt;&lt;a href=&quot;#微信小程序-评论留言功能&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 评论留言功能&quot;&gt;&lt;/a&gt;微信小程序 评论留言功能&lt;/h3&gt;
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 下拉刷新 上拉加载</title>
    <link href="http://gengaiwei.com/2018/03/05/wx-onPullDownRefresh-onReachBottom/"/>
    <id>http://gengaiwei.com/2018/03/05/wx-onPullDownRefresh-onReachBottom/</id>
    <published>2018-03-05T09:36:08.000Z</published>
    <updated>2020-07-27T06:10:13.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh-onReachBottom"><a href="#微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh-onReachBottom" class="headerlink" title="微信小程序的上拉下滑，第一次展示的数据是在onLoad中 执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh/onReachBottom"></a>微信小程序的上拉下滑，第一次展示的数据是在onLoad中 执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh/onReachBottom</h3><blockquote><p>1.初次渲染数据列表</p></blockquote><pre><code>wx.request({    url: &apos;your url&apos;,    method: &apos;GET&apos;,    header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,    },    success: function (res) {        console.log(res)        let shareData = res.data.data        let meta = res.data.meta        that.setData({        shareData: shareData,        meta: meta, //后台        });        if (res.statusCode == 200) {        wx.hideLoading();        } else {        wx.hideLoading();        wx.showToast({            title: &apos;加载失败&apos;,            duration: 0,            mask: true,            success: function (res) { },        })        }    },    fail: function (res) {        wx.hideLoading();        wx.showToast({        title: &apos;加载失败&apos;,        icon: &apos;err&apos;,        duration: 2000        });    }});</code></pre><blockquote><p>2.上拉拉到第一页，调用后台接口，返回第一页数据列表</p></blockquote><pre><code>onPullDownRefresh: function () {    let that = this;    wx.showNavigationBarLoading();    wx.request({    url: &apos;your-url?page=1&apos;,    method: &apos;GET&apos;,    header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,        Token: wx.getStorageSync(&apos;openid&apos;),    },    success: function (res) {        console.log(res)        let shareData = res.data.data        that.setData({        shareData: shareData        });        if (res.statusCode == 200) {        wx.hideLoading();        } else {        wx.hideLoading();        wx.showToast({            title: &apos;加载失败&apos;,            duration: 0,            mask: true,            success: function (res) { },        })        }    },    fail: function (res) {        wx.hideLoading();        wx.showToast({        title: &apos;加载失败&apos;,        icon: &apos;err&apos;,        duration: 2000        });    }    });},</code></pre><blockquote><p>3.下滑，有的是后台返回页数，然后前端进行计算，或者后台在接口里是链接，这样直接判断链接</p></blockquote><pre><code>onReachBottom: function () {    let that = this;    wx.showLoading({    title: &apos;加载中...&apos;,    })    console.log(that.data.meta.pagination.links.next)    if (that.data.meta.pagination.links.next) {    wx.request({        url: that.data.meta.pagination.links.next,        method: &apos;GET&apos;,        header: {        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,        Token: wx.getStorageSync(&apos;openid&apos;),        },        success: function (res) {        console.log(res)        var aftherlist = that.data.shareData        var meta = res.data.meta        for (var i = 0; i &lt; res.data.data.length; i++) {            aftherlist.push(res.data.data[i])        }        that.setData({            shareData: aftherlist,            meta: meta        });        if (res.statusCode == 200) {            wx.hideLoading();        } else {            wx.hideLoading();            wx.showToast({            title: &apos;加载失败&apos;,            duration: 0,            mask: true,            success: function (res) { },            })        }        },        fail: function (res) {        wx.hideLoading();        wx.showToast({            title: &apos;加载失败&apos;,            icon: &apos;err&apos;,            duration: 2000        });        }    });    } else {    console.log(that.data.meta.pagination.links.next)    wx.showToast({        title: &apos;没有更多数据了&apos;,        mask: true,    })    }},</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接口，展示数据列表，当用户上拉下滑的时候执行onPullDownRefresh-onReachBottom&quot;&gt;&lt;a href=&quot;#微信小程序的上拉下滑，第一次展示的数据是在onLoad中-执行数据接
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://gengaiwei.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://gengaiwei.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
